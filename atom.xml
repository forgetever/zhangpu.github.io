<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>听城</title>
  <subtitle>Life is too short to be ordinary</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangpu1211.github.io/"/>
  <updated>2018-09-28T07:50:14.353Z</updated>
  <id>https://zhangpu1211.github.io/</id>
  
  <author>
    <name>听城</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Colaboratory配合Google Drive使用GPU运行机器学习代码</title>
    <link href="https://zhangpu1211.github.io/2018/09/28/Colaboratory%E9%85%8D%E5%90%88Google-Drive%E4%BD%BF%E7%94%A8GPU%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81/"/>
    <id>https://zhangpu1211.github.io/2018/09/28/Colaboratory配合Google-Drive使用GPU运行机器学习代码/</id>
    <published>2018-09-28T07:48:59.000Z</published>
    <updated>2018-09-28T07:50:14.353Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>参考：<br> <a href="https://medium.com/deep-learning-turkey/google-colab-free-gpu-tutorial-e113627b9f5d" target="_blank" rel="noopener">https://medium.com/deep-learning-turkey/google-colab-free-gpu-tutorial-e113627b9f5d</a><br><a href="https://blog.csdn.net/ssssdbucdbod/article/details/80397808" target="_blank" rel="noopener">https://blog.csdn.net/ssssdbucdbod/article/details/80397808</a><br><a href="https://blog.csdn.net/Lee412726/article/details/82854746" target="_blank" rel="noopener">https://blog.csdn.net/Lee412726/article/details/82854746</a><br>提前声明，你需要有一个google 账号，某些过程可能需要科学上网哦！</p>
</blockquote>
<h3 id="新建或上传ipnb文件，并用Colaboratory打开"><a href="#新建或上传ipnb文件，并用Colaboratory打开" class="headerlink" title="新建或上传ipnb文件，并用Colaboratory打开"></a>新建或上传ipnb文件，并用Colaboratory打开</h3><p><img src="https://upload-images.jianshu.io/upload_images/2065390-e527cc5c2eef5d79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>然后再修改-&gt;笔记本设置中可以更改py文件类型以及GPU、TPU加速<br><img src="https://upload-images.jianshu.io/upload_images/2065390-f09ac832789c3e70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>此时你已经可以使用GPU畅快的运行代码了</p>
<h3 id="建立文件与google-drive关联"><a href="#建立文件与google-drive关联" class="headerlink" title="建立文件与google drive关联"></a>建立文件与google drive关联</h3><p>由于每次打开文件后台资源都是随机分配的，在运行代码之后一定要记得<strong>将结果保存</strong>。当然有的时候我们可以直接将所需文件上传到google drive上，由于资源随机分配，因此需要建立他们之间的关系。<strong>以下操作每次打开的时候，也需要重新执行</strong>。</p>
<ul>
<li><p>第一步进行授权绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">!apt-get install -y -qq software-properties-common python-software-properties module-init-tools</span><br><span class="line">#!add-apt-repository -y ppa:alessandro-strada/ppa 2&gt;&amp;1 &gt; /dev/null</span><br><span class="line">#!apt-get update -qq 2&gt;&amp;1 &gt; /dev/null</span><br><span class="line">#!apt-get -y install -qq google-drive-ocamlfuse fuse</span><br><span class="line">!wget https://launchpad.net/~alessandro-strada/+archive/ubuntu/google-drive-ocamlfuse-beta/+build/15331130/+files/google-drive-ocamlfuse_0.7.0-0ubuntu1_amd64.deb</span><br><span class="line">!dpkg -i google-drive-ocamlfuse_0.7.0-0ubuntu1_amd64.deb</span><br><span class="line">!apt-get install -f</span><br><span class="line">!apt-get -y install -qq fuse</span><br><span class="line">from google.colab import auth</span><br><span class="line">auth.authenticate_user()</span><br><span class="line">from oauth2client.client import GoogleCredentials</span><br><span class="line">creds = GoogleCredentials.get_application_default()</span><br><span class="line">import getpass</span><br><span class="line">!google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125; &lt; /dev/null 2&gt;&amp;1 | grep URL</span><br><span class="line">vcode = getpass.getpass()</span><br><span class="line">!echo &#123;vcode&#125; | google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步关联google drive</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!mkdir -p drive</span><br><span class="line">!google-drive-ocamlfuse drive</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 指定当前的工作目录</span><br><span class="line">import os</span><br><span class="line"># 此处为google drive中的文件路径,drive为之前指定的工作根目录要加上.</span><br><span class="line">#Colab Notebooks为你的文件存放的路径，可以自行更改</span><br><span class="line">os.chdir(&quot;drive/Colab Notebooks&quot;)</span><br></pre></td></tr></table></figure>
<p>此时你可以用<code>!ls</code>命令查看路径是否正确<br>之后就可以尽情使用啦</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考：&lt;br&gt; &lt;a href=&quot;https://medium.com/deep-learning-turkey/google-colab-free-gpu-tutorial-e113627b9f5d&quot; target=&quot;_blank&quot; rel=&quot;n
    
    </summary>
    
    
      <category term="tool" scheme="https://zhangpu1211.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>&#39;新的开始&#39;</title>
    <link href="https://zhangpu1211.github.io/2018/09/13/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>https://zhangpu1211.github.io/2018/09/13/新的开始/</id>
    <published>2018-09-13T11:52:55.000Z</published>
    <updated>2018-09-13T11:58:59.781Z</updated>
    
    <content type="html"><![CDATA[<p>过了许久，终于打算重新开始更新博客了，过去的事情追不回来，珍惜眼前，做好现在该做的事情。从现在开始努力！！！加油，各位</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过了许久，终于打算重新开始更新博客了，过去的事情追不回来，珍惜眼前，做好现在该做的事情。从现在开始努力！！！加油，各位&lt;/p&gt;

    
    </summary>
    
      <category term="生活" scheme="https://zhangpu1211.github.io/categories/life/"/>
    
    
      <category term="Lif" scheme="https://zhangpu1211.github.io/tags/Lif/"/>
    
  </entry>
  
  <entry>
    <title>matlab信息增益实现</title>
    <link href="https://zhangpu1211.github.io/2017/10/16/matlab%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zhangpu1211.github.io/2017/10/16/matlab信息增益实现/</id>
    <published>2017-10-16T01:37:55.000Z</published>
    <updated>2017-10-16T01:38:56.516Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一般地，一个决策树包含一个根节点，若干个内部节点和若干个叶节点，叶结点对应决策结果，其他每个节点对应于一个属性测试，每个结点包含的样本集合根据属性测试的结果被划分到子节点中；根节点包含样本全集，从根节点到每个叶节点的路径对应了一个判定测试序列。决策树学习的目的是为了产生一颗泛化能力强，处理未见实例能力强的决策树。</p>
</blockquote>
<p><strong>信息熵</strong><br>信息熵是度量样本集合纯度最常用的一种指标，假定当前样本集合D中第k类样本所占比例为pk(1,2,..|y|),则D的信息熵定义为</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2065390-0f76ac7ea232c7e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>其中Ent(D)的值越小，则D的纯度越高。</p>
<p><strong>信息增益</strong><br>假定离散属性a有V个可能的取值a1,a2,…,aV,若使用a来对样本集D进行划分，则会产生V个分支节点，其中第v个分支节点包含了D中所有在属性a上取值为av的样本，记为Dv,根据信息熵的公式，在考虑到不同的分支节点所包含的样本数不同，给分支节点赋予权重|Dv|/|D|,即样本数越多的分支节点的影响越大，于是可计算出用属性a对样本集D进行划分所获得的”信息增益”。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2065390-be4733f67b03c33a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>一般而言，信息增益越大，则意味着使用属性a来进行划分所得的”纯度提升”越大。因此，我们可以用信息增益来进行决策树的划分属性选择。</p>
<p><strong>实例分析</strong><br>以下表的数据为例：其中有17个训练正例，学习目标是预测是不是好瓜的决策树。分类目标|Y|=2</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2065390-32d6e37a597f2df8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>信息熵计算得</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2065390-9b718bffe55882fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2065390-6cf20184358dff72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2065390-2ea1446f8382eaac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>上述实现代码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line">data = csvread(&apos;watermelon2.0.csv&apos;);</span><br><span class="line">InforGain = gain(data);</span><br><span class="line"></span><br><span class="line">function InforGain = gain(data)</span><br><span class="line">    [m, n] = size(data);</span><br><span class="line">    InforGain = zeros(n-1,2);</span><br><span class="line">    labels = data(:,n);</span><br><span class="line">    for i=1:n</span><br><span class="line">        tmp&#123;i&#125; = [];</span><br><span class="line">        percen&#123;i&#125; = [];</span><br><span class="line">        col = data(:,i);</span><br><span class="line">        unicol = unique(col);</span><br><span class="line">        %计算每一列有几类，并把每一类的信息熵和比例存储起来</span><br><span class="line">        for j = 1:length(unicol)</span><br><span class="line">            num = length(find(col==unicol(j)));</span><br><span class="line">            pnum = length(find(col==unicol(j) &amp; labels == 1));</span><br><span class="line">            rate = pnum/num;</span><br><span class="line">            if i==7</span><br><span class="line">                rate = num/length(labels);</span><br><span class="line">            end</span><br><span class="line">            gain = -(rate*log2(rate)+(1-rate)*log2(1-rate));</span><br><span class="line">            tmp&#123;i&#125;=[tmp&#123;i&#125; gain];</span><br><span class="line">            percen&#123;i&#125;=[percen&#123;i&#125; num/length(col)];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    %整体信息熵</span><br><span class="line">    InforEntropy = tmp&#123;length(tmp)&#125;(1);</span><br><span class="line">    %将NAN转化为0</span><br><span class="line">    for i = 1:length(tmp)</span><br><span class="line">        tmp&#123;i&#125;(isnan(tmp&#123;i&#125;)) = 0;</span><br><span class="line">        %disp(tmp&#123;i&#125;);</span><br><span class="line">    end</span><br><span class="line">    %求每一个属性列的信息增益</span><br><span class="line">    for i = 1:length(percen)-1</span><br><span class="line">        InforGain(i,:) = [i,roundn(InforEntropy-sum(tmp&#123;i&#125;.*percen&#123;i&#125;),-3)];</span><br><span class="line">        disp(InforEntropy-sum(tmp&#123;i&#125;.*percen&#123;i&#125;));</span><br><span class="line">    end</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一般地，一个决策树包含一个根节点，若干个内部节点和若干个叶节点，叶结点对应决策结果，其他每个节点对应于一个属性测试，每个结点包含的样本集合根据属性测试的结果被划分到子节点中；根节点包含样本全集，从根节点到每个叶节点的路径对应了一个判定测试序列。决策
    
    </summary>
    
      <category term="算法" scheme="https://zhangpu1211.github.io/categories/Algorithm/"/>
    
    
      <category term="matlab" scheme="https://zhangpu1211.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab自助法实现</title>
    <link href="https://zhangpu1211.github.io/2017/10/16/matlab%E8%87%AA%E5%8A%A9%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zhangpu1211.github.io/2017/10/16/matlab自助法实现/</id>
    <published>2017-10-16T01:37:40.000Z</published>
    <updated>2017-10-16T01:38:31.162Z</updated>
    
    <content type="html"><![CDATA[<p>方法：以bootstrap sampling为基础，给定包含m个样本的数据集，我们对它进行采样产生数据集D’：每次随机从D中挑选一个样本，将其拷贝放入D’，然后将该样本放回初始数据集D中，使得该样本在下次采样时仍有可能被采到；这个过程重复m次以后，我们就得到了包含m个样本的数据集D’。将D’用作训练集，D\D’用作测试集；这样实际评估的模型与期望评估的模型都使用m个训练样本，而仍有数据总量约1/3的、没在训练集中出现的样本用于测试，这样的测试结果，也成为“包外估计”（out-of bag estimate）.</p>
<p>在这个过程中，样本在m次采样中始终不被采到的概率是(1-1/m)m，取极限得到<br>即通过自助采样，初始数据集D中约有36.8%的样本未出现在采样数据集D’中。</p>
<p>使用条件：<br>（1）在数据集较小，难以有效划分训练/测试集时很有用；<br>（2）可从初始数据集中产生多个不同的训练集，对集成学习等方法很有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">data=csvread(&apos;irisdata.csv&apos;);</span><br><span class="line">[s,t]=zizhu(data);</span><br><span class="line">csvwrite(&apos;s.csv&apos;,s);</span><br><span class="line">csvwrite(&apos;t.csv&apos;,t);</span><br><span class="line"></span><br><span class="line">function [s,t]=zizhu(data)</span><br><span class="line">    t = data;</span><br><span class="line">    [m,n] = size(data);</span><br><span class="line">    s = zeros(m,n);</span><br><span class="line">    labels = [];</span><br><span class="line">    for i=1:m</span><br><span class="line">        index = UNIDRND(m);</span><br><span class="line">        labels = [labels index];</span><br><span class="line">        s(i,:) = data(index,:);</span><br><span class="line">    end</span><br><span class="line">    kind=unique(labels);</span><br><span class="line">    disp(length(kind))</span><br><span class="line">    t(kind,:) = [];</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;方法：以bootstrap sampling为基础，给定包含m个样本的数据集，我们对它进行采样产生数据集D’：每次随机从D中挑选一个样本，将其拷贝放入D’，然后将该样本放回初始数据集D中，使得该样本在下次采样时仍有可能被采到；这个过程重复m次以后，我们就得到了包含m个样本的
    
    </summary>
    
      <category term="算法" scheme="https://zhangpu1211.github.io/categories/Algorithm/"/>
    
    
      <category term="matlab" scheme="https://zhangpu1211.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab流出法实现</title>
    <link href="https://zhangpu1211.github.io/2017/10/16/matlab%E6%B5%81%E5%87%BA%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zhangpu1211.github.io/2017/10/16/matlab流出法实现/</id>
    <published>2017-10-16T01:35:19.000Z</published>
    <updated>2017-10-16T01:36:55.611Z</updated>
    
    <content type="html"><![CDATA[<p>留出法(hold-out)<br>方法：直接将数据集D划分为两个互斥的集合，其中一个集合作为训练集S，另一个作为测试集T，即.在S上训练出模型后，用T来评估其作为测试误差，作为对泛化误差的估计。</p>
<p>以二分类任务为例，假定D包含1000个样本，将其划分为S包含700个样本，T包含300个样本，用S进行训练，如果模型在T上有90个样本分类错误，那么其错误率为（90/300）*100%=30%，精度为1-30%=70%。</p>
<p>注意事项：<br>（1）训练/测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程引入额外的偏差而对最终结果产生影响。例如在分类任务中至少要保持样本的类别比例相似，尝采用分层采样的方法，即采样过程中保留类别比例。<br>（2）即便在给定训练/测试集的样本比例后，仍存在多种划分方式对初始数据集D进行分割。因此，单次使用留出法得到的估计结果往往不够稳定可靠，在使用留出法时，一般要采用若干次随机划分、重复进行试验评估或取平均值作为留出法的评估结果。</p>
<p>在这里，还有一个窘境：若训练集S包含绝大多数样本，则训练处的模型可能更接近于用D训练出的模型，但由于T比较小，评估结果可能不够稳定准确，测试集小，评估结果的方差较大；若令测试集T多包含一些样本，则训练集S与差别更大了，被评估的模型与用D训练出的模型相比可能有较大的差别，从而降低了评估结果的保真性（fidelity）。</p>
<p>常见解决方法：将大约2/3~4/5的样本用于训练，剩余样本用于测试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line">data = csvread(&apos;irisdata.csv&apos;);</span><br><span class="line">[S,T]=divide(data,0.7);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function [S,T]=divide(data,rate)</span><br><span class="line">    S = [];</span><br><span class="line">    T = [];</span><br><span class="line">    [m, n] = size(data);</span><br><span class="line">    labels = data(:,n);</span><br><span class="line">    labelsClass = unique(labels);</span><br><span class="line">    weight = [];</span><br><span class="line">    for i=1:length(labelsClass)</span><br><span class="line">        weight(i) = round(sum(ismember(labels,labelsClass(i)))*rate);</span><br><span class="line">    end</span><br><span class="line">    for i=1:length(labelsClass)</span><br><span class="line">        index = find(labels==labelsClass(i));</span><br><span class="line">        randomIndex = index(randperm(length(index)));</span><br><span class="line">        S = [S;data(randomIndex(1:weight(i)),:)];</span><br><span class="line">        T = [T;data(randomIndex(weight(i)+1:sum(ismember(labels,labelsClass(i)))),:)];</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;留出法(hold-out)&lt;br&gt;方法：直接将数据集D划分为两个互斥的集合，其中一个集合作为训练集S，另一个作为测试集T，即.在S上训练出模型后，用T来评估其作为测试误差，作为对泛化误差的估计。&lt;/p&gt;
&lt;p&gt;以二分类任务为例，假定D包含1000个样本，将其划分为S包含70
    
    </summary>
    
      <category term="算法" scheme="https://zhangpu1211.github.io/categories/Algorithm/"/>
    
    
      <category term="matlab" scheme="https://zhangpu1211.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>python解决八数码问题</title>
    <link href="https://zhangpu1211.github.io/2017/10/10/python%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://zhangpu1211.github.io/2017/10/10/python解决八数码问题/</id>
    <published>2017-10-10T13:20:22.000Z</published>
    <updated>2017-10-10T13:22:21.108Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>八数码问题也称为九宫问题。在3×3的棋盘，摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始状态转变成目标状态的移动棋子步数最少的移动步骤。</p>
</blockquote>
<p>一开始也是两眼一抹黑，连八数码是什么都不知道，经过度娘得到如上结果。那该如何实现呢？如果移动数字的话，8个数字，每次移动有4种选择，那就是32个种移动方案。那移动空格就只有4种选择，一下子清楚了很多。至于存储方案当然是数组了，交换起来多方便，是吧？<br>实现方式呢？最初实验要求使用回溯算法解决，什么，回溯？！那不是和深度优先一样吗？无脑走找结果？算了，先试试吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">#返回两个数组对应位置相同值的个数</span><br><span class="line">def calc(state1):</span><br><span class="line">    b = np.array([[1, 2, 3], [8, 0, 4], [7, 6, 5]])</span><br><span class="line">    postion = np.where(state1 == b)</span><br><span class="line">    return len(state1[postion])</span><br><span class="line">#打印八数码</span><br><span class="line">def showInfo(a):</span><br><span class="line">    for i in range(3):</span><br><span class="line">        for j in range(3):</span><br><span class="line">            print(a[i, j], end=&apos;   &apos;)</span><br><span class="line">        print(&quot;\n&quot;)</span><br><span class="line">    print(&apos;-&gt;&apos;)</span><br><span class="line">directions = [&apos;up&apos;, &apos;down&apos;, &apos;left&apos;, &apos;right&apos;]</span><br><span class="line"></span><br><span class="line">def SubStates(state):</span><br><span class="line">    subStates = []</span><br><span class="line">    row, col = np.where(state==0)</span><br><span class="line">    for direction in directions:</span><br><span class="line">        if &apos;left&apos; == direction and col &gt; 0:</span><br><span class="line">            s = state.copy()</span><br><span class="line">            s[row, col],s[row, col - 1] = s[row, col - 1],s[row, col]</span><br><span class="line">            subStates.append(s)</span><br><span class="line">        if &apos;up&apos;  == direction and row &gt; 0:</span><br><span class="line">            s = state.copy()</span><br><span class="line">            s[row, col],s[row - 1, col] = s[row - 1, col],s[row, col]</span><br><span class="line">            subStates.append(s)</span><br><span class="line">        if &apos;down&apos;  == direction and row &lt; 2:</span><br><span class="line">            s = state.copy()</span><br><span class="line">            s[row, col],s[row + 1, col] = s[row + 1, col],s[row, col]</span><br><span class="line">            subStates.append(s)</span><br><span class="line">        if &apos;right&apos;  == direction and col &lt; 2:</span><br><span class="line">            s = state.copy()</span><br><span class="line">            s[row, col],s[row, col + 1] = s[row, col + 1],s[row, col]</span><br><span class="line">            subStates.append(s)</span><br><span class="line">    return subStates</span><br><span class="line">def DFS(first):</span><br><span class="line">    stack = []</span><br><span class="line">    stack.append(first)</span><br><span class="line">    count = -1</span><br><span class="line">    while stack:</span><br><span class="line">        count += 1</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        showInfo(node)</span><br><span class="line">        if calc(node) == 9:</span><br><span class="line">            return True,count</span><br><span class="line">        s = SubStates(node)</span><br><span class="line">        #res = sorted(s, key=calc)</span><br><span class="line">        for x in res:</span><br><span class="line">            stack.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#主函数</span><br><span class="line">def main():</span><br><span class="line">    start = np.array([[0, 1, 3], [8, 2, 4], [7, 6, 5]])</span><br><span class="line">    #start = np.array([[2, 8, 3], [1, 0, 4], [7, 6, 5]])</span><br><span class="line">    res,count = DFS(start)</span><br><span class="line">    if res:</span><br><span class="line">        print(&apos;经过%d次变换结束&apos; %count)</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<p>用迭代方式很容易的写出了深度优先算法，可是貌似跑不出结果。。。what a fuck，什么鬼？遂找了个只移动两次的，运行，还是不行。随机压栈太疯狂了，加点约束吧。每次找和最终结果最相似的出栈应该可以。<strong><em>（这里说一下为了防止无限次循环，用宽度优先搜素比较合适，只需把pop()改成pop(0),如果用到排序的话那就要按相似度由高到低排列了）</em></strong>嗯，加上这句<code>res = sorted(s, key=calc)</code>,压栈前按<strong><em>相似度由低到高</em></strong>做一次排序。移动两次的果然跑出来了，可是移动多次的还是不行。<br>得，再想办法吧。做一个界限函数，<strong><em>用八数码迭代出来的层数加上相似度来搜索</em></strong>。这个值在一定限度才入栈，否则舍弃。<br>这里我将节点封装成一个类来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">class eightPuzzle(object):</span><br><span class="line"></span><br><span class="line">    directions = [&apos;up&apos;, &apos;down&apos;, &apos;left&apos;, &apos;right&apos;]</span><br><span class="line">    max = 7</span><br><span class="line">    def __init__(self,arr,cost=0,parent=None):</span><br><span class="line">        self.arr = arr</span><br><span class="line">        self.cost = cost</span><br><span class="line">        self.parent = parent</span><br><span class="line"></span><br><span class="line">    def getCost(self):</span><br><span class="line">        return self.cost</span><br><span class="line">    # 返回两个数组对应位置相同值的个数</span><br><span class="line">    def calc(self,state):</span><br><span class="line">        final = np.array([[1, 2, 3], [8, 0, 4], [7, 6, 5]])</span><br><span class="line">        postion = np.where(state.arr == final)</span><br><span class="line">        return len(state.arr[postion])</span><br><span class="line"></span><br><span class="line">    # 打印八数码</span><br><span class="line">    def showInfo(self):</span><br><span class="line">        for i in range(3):</span><br><span class="line">            for j in range(3):</span><br><span class="line">                print(self.arr[i, j], end=&apos;   &apos;)</span><br><span class="line">            print(&quot;\n&quot;)</span><br><span class="line">        print(&apos;-&gt;&apos;)</span><br><span class="line"></span><br><span class="line">    def calc2(self, state1, stop):</span><br><span class="line">        for x in stop:</span><br><span class="line">            postion = np.where(state1.arr == x.arr)</span><br><span class="line">            if len(state1.arr[postion]) == 9:</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    def SubStates(self):</span><br><span class="line">        subStates = []</span><br><span class="line">        row, col = np.where(self.arr==0)</span><br><span class="line">        for direction in self.directions:</span><br><span class="line">            if &apos;left&apos; == direction and col &gt; 0:</span><br><span class="line">                s = self.arr.copy()</span><br><span class="line">                s[row, col],s[row, col - 1] = s[row, col - 1],s[row, col]</span><br><span class="line">                new = eightPuzzle(s,self.cost+1,self)</span><br><span class="line">                subStates.append(new)</span><br><span class="line">            if &apos;up&apos;  == direction and row &gt; 0:</span><br><span class="line">                s = self.arr.copy()</span><br><span class="line">                s[row, col],s[row - 1, col] = s[row - 1, col],s[row, col]</span><br><span class="line">                new = eightPuzzle(s, self.cost + 1,self)</span><br><span class="line">                subStates.append(new)</span><br><span class="line">            if &apos;down&apos;  == direction and row &lt; 2:</span><br><span class="line">                s = self.arr.copy()</span><br><span class="line">                s[row, col],s[row + 1, col] = s[row + 1, col],s[row, col]</span><br><span class="line">                new = eightPuzzle(s, self.cost + 1,self)</span><br><span class="line">                subStates.append(new)</span><br><span class="line">            if &apos;right&apos;  == direction and col &lt; 2:</span><br><span class="line">                s = self.arr.copy()</span><br><span class="line">                s[row, col],s[row, col + 1] = s[row, col + 1],s[row, col]</span><br><span class="line">                new = eightPuzzle(s, self.cost + 1,self)</span><br><span class="line">                subStates.append(new)</span><br><span class="line">        return subStates</span><br><span class="line">    def DFS(self):</span><br><span class="line">        stack = []</span><br><span class="line">        stop = []</span><br><span class="line">        stack.append(self)</span><br><span class="line">        count = -1</span><br><span class="line">        while True:</span><br><span class="line">            if not stack:</span><br><span class="line">                return False,count,node</span><br><span class="line">            count += 1</span><br><span class="line">            #stack = sorted(stack, key=self.calc)</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            stop.append(node)</span><br><span class="line">            node.showInfo()</span><br><span class="line">            if self.calc(node) == 9:</span><br><span class="line">                return True,count,node</span><br><span class="line">            s = node.SubStates()</span><br><span class="line">            if s:</span><br><span class="line">                res = sorted(s, key=self.calc)</span><br><span class="line">            else:</span><br><span class="line">                continue</span><br><span class="line">            for x in res:</span><br><span class="line">                if (x.cost + 9 - self.calc(x))&lt; eightPuzzle.max:</span><br><span class="line">                    if self.calc2(x,stop):</span><br><span class="line">                        continue</span><br><span class="line">                    stack.append(x)</span><br><span class="line"></span><br><span class="line">def showInfo(result):</span><br><span class="line">    for node in result:</span><br><span class="line">        for i in range(3):</span><br><span class="line">            for j in range(3):</span><br><span class="line">                print(node.arr[i, j], end=&apos;   &apos;)</span><br><span class="line">            print(&apos;\n&apos;)</span><br><span class="line">        print(&apos;-&gt;&apos;)</span><br><span class="line">#主函数</span><br><span class="line">def main():</span><br><span class="line">    #start = np.array([[0, 1, 3], [8, 2, 4], [7, 6, 5]])</span><br><span class="line">    start = np.array([[2, 8, 3], [1, 0, 4], [7, 6, 5]])</span><br><span class="line">    p = eightPuzzle(start)</span><br><span class="line">    res,count,node = p.DFS()</span><br><span class="line">    result = []</span><br><span class="line">    if res:</span><br><span class="line">        print(&apos;经过%d次变换结束&apos; %count)</span><br><span class="line">        while node:</span><br><span class="line">            result.append(node)</span><br><span class="line">            node = node.parent</span><br><span class="line">        result.reverse()</span><br><span class="line">        showInfo(result)</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;规定范围内未找到合适路径，可增大界值&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<p>这次经过七次搜索得到了最终答案。<br>这时候发现输出很有意思，会出现初始状态。因此在深度搜索的过程中加了一个stop表，用来存储已经出栈的元素，每次入栈的时候查看若已经存在则扔掉。此时运行6次出现答案。<br>结束。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;八数码问题也称为九宫问题。在3×3的棋盘，摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始状态转变成目标状态
    
    </summary>
    
      <category term="算法" scheme="https://zhangpu1211.github.io/categories/Algorithm/"/>
    
    
      <category term="python" scheme="https://zhangpu1211.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>从零开始Hadoop集群环境搭建</title>
    <link href="https://zhangpu1211.github.io/2017/09/10/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHadoop%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://zhangpu1211.github.io/2017/09/10/从零开始Hadoop集群环境搭建/</id>
    <published>2017-09-10T05:42:11.000Z</published>
    <updated>2017-09-10T06:41:59.524Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本篇文章将从头开始介绍Hadoop大数据平台的一系列搭建工作，主要是搭建的具体操作步骤，思想方面涉及甚少，可以自行补充</p>
</blockquote>
<h4 id="虚拟机下载安装"><a href="#虚拟机下载安装" class="headerlink" title="虚拟机下载安装"></a>虚拟机下载安装</h4><p>我使用的是VMware station12，下载地址为链接：<a href="http://pan.baidu.com/s/1geX11pL" target="_blank" rel="noopener">http://pan.baidu.com/s/1geX11pL</a> 密码：uylp<br>本软件为注册软件现提供一个注册码<code>AV5R2-8LW53-484RP-H5YQZ-XU8RF</code>，大家也可以自行百度。</p>
<h4 id="centos下载"><a href="#centos下载" class="headerlink" title="centos下载"></a>centos下载</h4><p>因为工作中常用的为不带可视化界面的版本，现提供一个centos6.8_64下载，地址<a href="http://pan.baidu.com/s/1cEpvo6" target="_blank" rel="noopener">点我</a></p>
<h4 id="centos安装"><a href="#centos安装" class="headerlink" title="centos安装"></a>centos安装</h4><p>打开安装好的VMware station，右键选择新建虚拟机，选择典型安装。<br>选择稍后安装操作系统，点击下一步<br><img src="http://upload-images.jianshu.io/upload_images/2065390-c8ada8ff6b6af3be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>选择linux操作系统，版本为CentOS64位<br><img src="http://upload-images.jianshu.io/upload_images/2065390-ca2bbe7ec08e0534.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>输入计算机名称以及你想要安装的位置<br><img src="http://upload-images.jianshu.io/upload_images/2065390-355d06a32d8e9303.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>指定磁盘容量，这里要说明的是你选择的20G并不会一下占用你20G的硬盘空间，而是跟随你虚拟机大小进行变化的<br><img src="http://upload-images.jianshu.io/upload_images/2065390-024076e190f91388.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>点击完成即可<br><img src="http://upload-images.jianshu.io/upload_images/2065390-b84a75536fb90437.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>此时你会发现在你VMwarestation左面有了安装的虚拟机，现在需要做两件事。</p>
<ul>
<li>设定虚拟机镜像位置</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2065390-eaad752cdb93826b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>更改电脑虚拟化设置。有的电脑并没有开启Intel虚拟化，因此不能安装64位虚拟机。检测的方法是点击开启此虚拟机，如果进入安装界面则证明你的虚拟化是打开的，否则会报错，这时你需要开机进入BIOS，Advanced-CPU Setup将Intel Virtualization Technology和VT-d打开<br><img src="http://upload-images.jianshu.io/upload_images/2065390-8c6aca7aa21dbd55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>设置完成后选择开启此虚拟机，进入系统安装界面。这里需要注意的就是skip测试你的安装媒体。剩下的都是可视化的安装，自己选择就可以。<br><img src="http://upload-images.jianshu.io/upload_images/2065390-5eb8ff64cdc2590f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h4 id="Linux环境配置"><a href="#Linux环境配置" class="headerlink" title="Linux环境配置"></a>Linux环境配置</h4></li>
<li><p>修改Linux的主机名<br>进入<code>vi /etc/sysconfig/network</code>,修改内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=node-1</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改IP地址<br>如果你此时执行ifconfig命令你会发现并没有常见的etho网卡，这时因为系统默认没有启动。需要将配置文件改成如下内容。首先进入配置文件<code>vi /etc/sysconfig/network-scripts/ifcfg-eth0</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">IPADDR=192.168.213.100</span><br><span class="line">NETMASK=255.255.255.0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里需要注意的是ip地址的设置，首先你需要查看你的网络连接方式，我采用默认的NAT模式，从下图可以看到子网地址为192.168.213.0，因此我设置的为192.168.213.100。另外如果你想让虚拟机联网需要设置gateway和dns。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2065390-8475c9fae79c415e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>配置好后用<code>service network restart</code>重启网络服务，用<code>ifconfig</code>可以查看是否配置成功。然后可以在Windows上ping该ip查看是否可以ping通。ping通后就可以使用putty或者SecureCRT连接虚拟机了。</p>
<ul>
<li>配置主机名和IP地址的映射关系<br><code>vi /etc/hosts</code>打开hosts文件，新增一行<code>192.168.213.100  node-1</code></li>
<li>关闭防火墙<br>查看防火墙状态<br>service iptables status<br>关闭防火墙<br>service iptables stop<br>设置防火墙开机不启动<br>chkconfig iptables off</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2065390-a935b7b29f6251a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>最后reboot或者通过<code>hostname node-1</code> 以及<code>exit</code>,使我们配置的主机名生效</p>
<ul>
<li>删除Mac地址与网卡映射文件<br>我们想将这个虚拟机作为模板机，为了避免以后Mac地址冲突，因此要删除Mac地址与网卡映射文件，以后启动机器的时候会自动生成。<br><code>rm -rf /etc/udev/rules.d/70-persistent-net.rules</code><br>然后用<code>halt</code>关机<h4 id="创建克隆机"><a href="#创建克隆机" class="headerlink" title="创建克隆机"></a>创建克隆机</h4>做大数据肯定不可能只有一个虚拟机，我们现在用配置好的这台机器，克隆出几台虚拟机出来。</li>
<li>选择模板机，然后点击右键 –&gt; 选择Manage –&gt; clone -&gt;创建一个完整的克隆 –&gt;<br>-&gt;配置机器的名字和存放位置 </li>
<li>开启虚拟机之前一定要生成一个新的mac地址</li>
<li>开启虚拟机，修改其主机名和ip地址<br>如果在执行<code>service network restart</code>命令时出现以下错误，则可能是没有删除模板机Mac地址与网卡映射文件，注意这个文件每次启动都会自动生成的。解决方法是<code>rm -rf /etc/udev/rules.d/70-persistent-net.rules</code>删除该文件然后重启<br>都修改完成后可以用一台虚拟机依次ping其它虚拟机，可以ping通即可<h4 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改hosts文件</h4>在101机器上修改hosts文件，完成主机名和ip地址映射<br><img src="http://upload-images.jianshu.io/upload_images/2065390-61e440ea012f7776.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h4 id="ssh免密码登录"><a href="#ssh免密码登录" class="headerlink" title="ssh免密码登录"></a>ssh免密码登录</h4><ul>
<li>在第一台机器上生成一对钥匙，一个公钥，一个私钥<code>ssh-keygen –t rsa</code>执行上面的命令后，输入四个回车</li>
<li>将公钥拷贝到希望名登录的机器<code>ssh-copy-id 192.168.213.102</code>执行上面的命令第一次要输入第二台机器的密码</li>
<li>然后执行scp操作就不需要输入密码了<code>scp /etc/hosts root@192.168.213.102:/etc</code>，现在可以将修改好的hosts文件发送到其他具有公钥的机器。<br>注意这种免密码登录是单向的，如果想相互免密码登录则需要在每一台机器上都生成一个公钥和一个私钥。<h4 id="Hadoop集群规划"><a href="#Hadoop集群规划" class="headerlink" title="Hadoop集群规划"></a>Hadoop集群规划</h4>现在我们有四台机器，分别为node-1,node-2,node-3,node-4，我们要做成下图形式的架构。第一台作为主节点，其他三台作为从节点<br><img src="http://upload-images.jianshu.io/upload_images/2065390-b1b4e3599d803a32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h4 id="Java安装"><a href="#Java安装" class="headerlink" title="Java安装"></a>Java安装</h4>将安装包上传到虚拟机上</li>
<li>安装Java<ul>
<li>创建文件夹<code>mkdir /usr/java</code></li>
<li>解压<code>tar -zxvf jdk.tar.gz -C /usr/java</code></li>
<li>添加环境变量<br>进入文件<code>vi /etc/profile</code>，按G到文件末尾，按o插入一行，加入下面语句<br><code>export JAVA_HOME=/usr/java/jdk1.8.0_111</code><br><code>export PATH=$PATH:$JAVA_HOME/bin</code><br>执行<code>source /etc/profile</code>重新加载环境变量</li>
<li>若需要传到其他虚拟机上则<br><code>scp –r /usr/java/ node-2:/usr</code><br><code>scp  /etc/profile node-2:/etc</code></li>
</ul>
</li>
</ul>
<h4 id="Hadoop安装"><a href="#Hadoop安装" class="headerlink" title="Hadoop安装"></a>Hadoop安装</h4><ul>
<li><p>解压Hadoop<br><code>mkdir /bigdata</code><br><code>tar -zxvf hadoop-2.6.5.tar.gz -C /bigdata/</code></p>
</li>
<li><p>在Hadoop安装包目录下有几个比较重要的目录<br>sbin : 启动或停止Hadoop相关服务的脚本<br>bin ：对Hadoop相关服务（HDFS,YARN）进行操作的脚本<br>etc : Hadoop的配置文件目录<br>share ：Hadoop的依赖jar包和文档，文档可以被删掉<br>lib ：Hadoop的本地库（对数据进行压缩解压缩功能的）</p>
</li>
<li>修改配置文件<br>进入到Hadoop的etc目录下<br><code>cd /bigdata/hadoop-2.6.5/etc/hadoop</code></li>
</ul>
<p>修改第1个配置文<br><code>vi hadoop-env.sh</code><br><code>export JAVA_HOME=/usr/java/jdk1.8.0_111</code></p>
<p>修改第2个配置文件<br><code>vi core-site.xml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;!-- 配置hdfs的namenode（老大）的地址 --&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hdfs://node-1:9000&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 配置Hadoop运行时产生数据的存储目录，不是临时的数据 --&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/bigdata/hadoop-2.6.5/tmp&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>
<p>修改第3个配置文件<br><code>vi hdfs-site.xml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line"> &lt;!-- 指定HDFS存储数据的副本数据量 --&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;3&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>
<p>修改第4个配置文件<br><code>mv mapred-site.xml.template mapred-site.xml</code><br><code>vi mapred-site.xml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;!-- 指定mapreduce编程模型运行在yarn上  --&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>
<p>修改第5个配置文件<br><code>vi yarn-site.xml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;!-- 指定yarn的老大（ResourceManager的地址） --&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;node-1&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!-- mapreduce执行shuffle时获取数据的方式 --&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>
<p>第6个配置文件slaves<br><code>vi slaves</code><br>原来的localhost要删掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node-2</span><br><span class="line">node-3</span><br><span class="line">node-4</span><br></pre></td></tr></table></figure></p>
<p>将配置好的Hadoop安装包拷贝到其他服务上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp -r /bigdata  node-2:/</span><br><span class="line">scp -r /bigdata  node-3:/</span><br><span class="line">scp -r /bigdata  node-4:/</span><br></pre></td></tr></table></figure></p>
<p>在第一台机器（NameNode所在的机器）上对hdfs进行初始化（格式化HDFS）<br><code>cd /bigdata/hadoop-2.6.5/bin/</code><br><code>./hdfs namenode -format</code></p>
<p>配置自己到自己的免密码登录，输入当前机器的密码<br><code>ssh-copy-id node-1</code></p>
<p>在第一台机器（NameNode所在的机器）上对hdfs进行初始化（格式化HDFS）<br><code>cd /bigdata/hadoop-2.6.5/bin/</code><br><code>./hdfs namenode -format</code><br>格式化成功的标志是出现以下提示<br><img src="http://upload-images.jianshu.io/upload_images/2065390-09a61c18e10d0ea8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>配置自己到自己的免密码登录，输入当前机器的密码<br>ssh-copy-id node-1</p>
<h4 id="启动并测试Hadoop"><a href="#启动并测试Hadoop" class="headerlink" title="启动并测试Hadoop"></a>启动并测试Hadoop</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /bigdata/hadoop-2.6.5/sbin/</span><br><span class="line">./start-dfs.sh</span><br><span class="line">./start-yarn.sh</span><br></pre></td></tr></table></figure>
<p>可以使用jps检查进程是否存在</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2065390-c61de5d0574f2d7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="node1"><br><img src="http://upload-images.jianshu.io/upload_images/2065390-3620d5ba6df782c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="node2"><br>也可以访问网页测试<br>访问hdfs的管理界面<br>192.168.213.101:50070</p>
<p>访问yarn的管理界面<br>192.168.213.101:8088</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2065390-bc5ee303dbf594a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>关闭hdfs/yarn服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./stop-dfs.sh</span><br><span class="line">./stop-yarn.sh</span><br></pre></td></tr></table></figure></p>
<h4 id="上传文件到HDFS上"><a href="#上传文件到HDFS上" class="headerlink" title="上传文件到HDFS上"></a>上传文件到HDFS上</h4><p>上传文件<br><code>/bigdata/hadoop-2.6.5/bin/hdfs dfs -put /root/install.log hdfs://node-1:9000/</code><br>查看文件信息<br><code>/bigdata/hadoop-2.6.5/bin/hdfs dfs -ls hdfs://node-1:9000/</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2065390-f9bb604aed19a2e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="HDFS动态扩容"><a href="#HDFS动态扩容" class="headerlink" title="HDFS动态扩容"></a>HDFS动态扩容</h4><p>查看现在DataNode情况可以在Hadoop的bin目录下执行<code>./hdfs dfsadmin -report</code>，可以看到存活的DataNode。现在为3个。<br>下面为扩容的具体步骤：</p>
<ul>
<li>准备一台新的服务器（最好是跟原集群的机器相同配置）</li>
<li>为新的服务器准备系统环境（主机名、IP地址、防火墙、JDK环境、hosts文件）</li>
<li>将新的服务器连入原集群网络（测试是否可以ping通）</li>
<li>从原集群中拷贝一个hadoop的安装目录到新节点上，并且删除原datanode的工作目录（这里配置的为tmp目录）</li>
<li>修改/bigdata/hadoop-2.6.5/etc/hadoop/slaves 文件，加入新节点的主机名</li>
<li>在新节点上用命令：hadoop-daemon.sh start datanode 启动datanode，就会自动加入集群</li>
<li>重启start-dfs,start-yarn<h4 id="hadoop集群恢复终极解决方案"><a href="#hadoop集群恢复终极解决方案" class="headerlink" title="hadoop集群恢复终极解决方案"></a>hadoop集群恢复终极解决方案</h4></li>
<li>在每一台机器上用命令杀掉所有java进程：  killall java</li>
<li>在每一台机器上删掉hadoop安装目录中的tmp文件夹</li>
<li>在node-1上格式化namenode：   hadoop namenode -format</li>
<li>在node-1上执行脚本来启动整个集群：  start-dfs.sh<br>注意用这种方案会重新格式化hdsf，意味着原来上传的文件会全部丢失！！！<br>补充：关闭HDFS集群的命令：在node-1上：  stop-dfs.sh<br>关闭YARN集群的命令：在node-1上：  stop-yarn.sh</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇文章将从头开始介绍Hadoop大数据平台的一系列搭建工作，主要是搭建的具体操作步骤，思想方面涉及甚少，可以自行补充&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;虚拟机下载安装&quot;&gt;&lt;a href=&quot;#虚拟机下载安装&quot; class=&quot;hea
    
    </summary>
    
      <category term="编程" scheme="https://zhangpu1211.github.io/categories/program/"/>
    
    
      <category term="Hadoop" scheme="https://zhangpu1211.github.io/tags/Hadoop/"/>
    
      <category term="hdfs" scheme="https://zhangpu1211.github.io/tags/hdfs/"/>
    
  </entry>
  
  <entry>
    <title>Matplotlib 绘3D图</title>
    <link href="https://zhangpu1211.github.io/2017/09/05/Matplotlib-%E7%BB%983D%E5%9B%BE/"/>
    <id>https://zhangpu1211.github.io/2017/09/05/Matplotlib-绘3D图/</id>
    <published>2017-09-05T03:09:27.000Z</published>
    <updated>2017-09-05T03:10:59.580Z</updated>
    
    <content type="html"><![CDATA[<p>Matplotlib 也可以绘制 3D 图像，与二维图像不同的是，绘制三维图像主要通过 mplot3d 模块实现。但是，使用 Matplotlib 绘制三维图像实际上是在二维画布上展示，所以一般绘制三维图像时，同样需要载入 pyplot 模块。<br>mplot3d 模块下主要包含 4 个大类，分别是：</p>
<ul>
<li>mpl_toolkits.mplot3d.axes3d()</li>
<li>mpl_toolkits.mplot3d.axis3d()</li>
<li>mpl_toolkits.mplot3d.art3d()</li>
<li>mpl_toolkits.mplot3d.proj3d()</li>
</ul>
<p>其中，axes3d() 下面主要包含了各种实现绘图的类和方法。axis3d() 主要是包含了和坐标轴相关的类和方法。art3d() 包含了一些可将 2D 图像转换并用于 3D 绘制的类和方法。proj3d() 中包含一些零碎的类和方法，例如计算三维向量长度等。<br>一般情况下，我们用到最多的就是 mpl_toolkits.mplot3d.axes3d() 中的mpl_toolkits.mplot3d.axes3d.Axes3D() 类，而 Axes3D() 下面又存在绘制不同类型 3D 图的方法。你可以通过下面的方式导入 Axes3D()。<br><code>from mpl_toolkits.mplot3d.axes3d import Axes3D</code>或<code>from mpl_toolkits.mplot3d import Axes3D</code></p>
<h4 id="三维散点图"><a href="#三维散点图" class="headerlink" title="三维散点图"></a>三维散点图</h4><p>首先，我们导入 numpy 随机生成一组数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># x, y, z 均为 0 到 1 之间的 100 个随机数</span><br><span class="line">x = np.random.normal(0, 1, 100)</span><br><span class="line">y = np.random.normal(0, 1, 100)</span><br><span class="line">z = np.random.normal(0, 1, 100)</span><br></pre></td></tr></table></figure></p>
<p>接下来，开始绘图。第一步是载入 2D, 3D 绘图模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from mpl_toolkits.mplot3d import Axes3D</span><br><span class="line">import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure></p>
<p>第二步，使用 Axes3D() 创建 3D 图形对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = Axes3D(fig)</span><br></pre></td></tr></table></figure></p>
<p>最后，调用散点图绘制方法绘图并显示出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax.scatter(x, y, z)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<h4 id="三维线型图"><a href="#三维线型图" class="headerlink" title="三维线型图"></a>三维线型图</h4><p>线形图和散点图相似，需要传入 x, y, z 三个坐标的数值。详细的代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 载入模块</span><br><span class="line">from mpl_toolkits.mplot3d import Axes3D</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># 生成数据</span><br><span class="line">x = np.linspace(-6 * np.pi, 6 * np.pi, 1000)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">z = np.cos(x)</span><br><span class="line"></span><br><span class="line"># 创建 3D 图形对象</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = Axes3D(fig)</span><br><span class="line"></span><br><span class="line"># 绘制线型图</span><br><span class="line">ax.plot(x, y, z)</span><br><span class="line"></span><br><span class="line"># 显示图</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<h4 id="三维柱状图"><a href="#三维柱状图" class="headerlink" title="三维柱状图"></a>三维柱状图</h4><p>绘制完线型图，我们继续尝试绘制三维柱状图，其实它的绘制步骤和上面同样非常相似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 载入模块</span><br><span class="line">from mpl_toolkits.mplot3d import Axes3D</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># 创建 3D 图形对象</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = Axes3D(fig)</span><br><span class="line"></span><br><span class="line"># 生成数据并绘图</span><br><span class="line">x = [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">for i in x:</span><br><span class="line">    y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">    z = abs(np.random.normal(1, 10, 10))</span><br><span class="line">    ax.bar(y, z, i, zdir=&apos;y&apos;, color=[&apos;r&apos;, &apos;g&apos;, &apos;b&apos;, &apos;y&apos;])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<h4 id="三维图曲面图"><a href="#三维图曲面图" class="headerlink" title="三维图曲面图"></a>三维图曲面图</h4><p>接下来需要绘制的三维曲面图要麻烦一些，我们需要对数据进行矩阵处理。其实和画二维等高线图很相似，只是多增加了一个维度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 载入模块</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from mpl_toolkits.mplot3d import Axes3D</span><br><span class="line"></span><br><span class="line"># 创建 3D 图形对象</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = Axes3D(fig)</span><br><span class="line"></span><br><span class="line"># 生成数据</span><br><span class="line">X = np.arange(-2, 2, 0.1)</span><br><span class="line">Y = np.arange(-2, 2, 0.1)</span><br><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line">Z = np.sqrt(X ** 2 + Y ** 2)</span><br><span class="line"></span><br><span class="line"># 绘制曲面图，并使用 cmap 着色</span><br><span class="line">ax.plot_surface(X, Y, Z, cmap=plt.cm.winter)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>cmap=plt.cm.winter 表示采用了 winter 配色方案，也就是下图的渐变色。</p>
<h4 id="混合图绘制"><a href="#混合图绘制" class="headerlink" title="混合图绘制"></a>混合图绘制</h4><p>混合图就是将两种不同类型的图绘制在一张图里。绘制混合图一般有前提条件，那就是两种不同类型图的范围大致相同，否则将会出现严重的比例不协调，而使得混合图失去意义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*</span><br><span class="line"># 载入模块</span><br><span class="line">from mpl_toolkits.mplot3d import Axes3D</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># 创建 3D 图形对象</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = Axes3D(fig)</span><br><span class="line"></span><br><span class="line"># 生成数据并绘制图 1</span><br><span class="line">x1 = np.linspace(-3 * np.pi, 3 * np.pi, 500)</span><br><span class="line">y1 = np.sin(x1)</span><br><span class="line">ax.plot(x1, y1, zs=0, c=&apos;red&apos;)</span><br><span class="line"></span><br><span class="line"># 生成数据并绘制图 2</span><br><span class="line">x2 = np.random.normal(0, 1, 100)</span><br><span class="line">y2 = np.random.normal(0, 1, 100)</span><br><span class="line">z2 = np.random.normal(0, 1, 100)</span><br><span class="line">ax.scatter(x2, y2, z2)</span><br><span class="line"></span><br><span class="line"># 显示图</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<h4 id="子图绘制"><a href="#子图绘制" class="headerlink" title="子图绘制"></a>子图绘制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*</span><br><span class="line"># 载入模块</span><br><span class="line">from mpl_toolkits.mplot3d import Axes3D</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># 创建 1 张画布</span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line">#===============</span><br><span class="line"></span><br><span class="line"># 向画布添加子图 1 </span><br><span class="line">ax1 = fig.add_subplot(1, 2, 1, projection=&apos;3d&apos;)</span><br><span class="line"></span><br><span class="line"># 生成子图 1 数据</span><br><span class="line">x = np.linspace(-6 * np.pi, 6 * np.pi, 1000)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">z = np.cos(x)</span><br><span class="line"></span><br><span class="line"># 绘制第 1 张图</span><br><span class="line">ax1.plot(x, y, z)</span><br><span class="line"></span><br><span class="line">#===============</span><br><span class="line"></span><br><span class="line"># 向画布添加子图 2</span><br><span class="line">ax2 = fig.add_subplot(1, 2, 2, projection=&apos;3d&apos;)</span><br><span class="line"></span><br><span class="line"># 生成子图 2 数据</span><br><span class="line">X = np.arange(-2, 2, 0.1)</span><br><span class="line">Y = np.arange(-2, 2, 0.1)</span><br><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line">Z = np.sqrt(X ** 2 + Y ** 2)</span><br><span class="line"></span><br><span class="line"># 绘制第 2 张图</span><br><span class="line">ax2.plot_surface(X, Y, Z, cmap=plt.cm.winter)</span><br><span class="line"></span><br><span class="line"># 显示图</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>我们可以来看一下这些代码。由于两张子图是绘制在 1 张画布上面的，所以这里需要提前创建 1 张画布。然后通过<code>.add_subplot()</code>添加子图，子图序号和二维绘图相似，只是注意 3D 绘图时要添加<code>projection=&#39;3d&#39;</code>参数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Matplotlib 也可以绘制 3D 图像，与二维图像不同的是，绘制三维图像主要通过 mplot3d 模块实现。但是，使用 Matplotlib 绘制三维图像实际上是在二维画布上展示，所以一般绘制三维图像时，同样需要载入 pyplot 模块。&lt;br&gt;mplot3d 模块下
    
    </summary>
    
      <category term="编程" scheme="https://zhangpu1211.github.io/categories/program/"/>
    
    
      <category term="python" scheme="https://zhangpu1211.github.io/tags/python/"/>
    
      <category term="matplotlib" scheme="https://zhangpu1211.github.io/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>Matplotlib 绘2D图</title>
    <link href="https://zhangpu1211.github.io/2017/09/05/Matplotlib-%E7%BB%982D%E5%9B%BE/"/>
    <id>https://zhangpu1211.github.io/2017/09/05/Matplotlib-绘2D图/</id>
    <published>2017-09-05T03:09:06.000Z</published>
    <updated>2017-09-05T03:10:36.383Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Matplotlib 是一个非常简单而又完善的开源绘图库。那么它到底有多简单呢？</p>
</blockquote>
<h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><p>首先<a href="https://matplotlib.org/2.0.2/Matplotlib.pdf" target="_blank" rel="noopener">官方文档</a>奉上<br>下面，我们通过 3 行代码绘制一张简单的折线图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">plt.plot([1,2,3,4,2,1,5,6,1])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2065390-b4e9b17d6216e0b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="折线图"></p>
<p>plt.plot() 是 pyplot 模块下面的直线绘制（折线图）方法类。示例中包含了一个[1,2,3,4,2,1,5,6,1]列表，该列表的值默认为y值，而 x 值会从 0 到 n-1，这也就是为什么你会发现3反而对应的是4。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">matplotlib.pyplot.angle_spectrum</td>
<td style="text-align:center">绘制电子波谱图</td>
</tr>
<tr>
<td style="text-align:center">matplotlib.pyplot.bar</td>
<td style="text-align:center">绘制柱状图</td>
</tr>
<tr>
<td style="text-align:center">matplotlib.pyplot.barh</td>
<td style="text-align:center">绘制直方图</td>
</tr>
<tr>
<td style="text-align:center">matplotlib.pyplot.broken_barh</td>
<td style="text-align:center">绘制水平直方图</td>
</tr>
<tr>
<td style="text-align:center">matplotlib.pyplot.contour</td>
<td style="text-align:center">绘制等高线图</td>
</tr>
<tr>
<td style="text-align:center">matplotlib.pyplot.errorbar</td>
<td style="text-align:center">绘制误差线</td>
</tr>
<tr>
<td style="text-align:center">matplotlib.pyplot.hexbin</td>
<td style="text-align:center">绘制六边形图案</td>
</tr>
<tr>
<td style="text-align:center">matplotlib.pyplot.hist</td>
<td style="text-align:center">绘制柱形图</td>
</tr>
<tr>
<td style="text-align:center">matplotlib.pyplot.hist2d</td>
<td style="text-align:center">绘制水平柱状图</td>
</tr>
<tr>
<td style="text-align:center">matplotlib.pyplot.imshow</td>
<td style="text-align:center">以图像显示</td>
</tr>
<tr>
<td style="text-align:center">matplotlib.pyplot.pie</td>
<td style="text-align:center">绘制饼状图</td>
</tr>
<tr>
<td style="text-align:center">matplotlib.pyplot.quiver</td>
<td style="text-align:center">绘制量场图</td>
</tr>
<tr>
<td style="text-align:center">matplotlib.pyplot.scatter</td>
<td style="text-align:center">散点图</td>
</tr>
<tr>
<td style="text-align:center">matplotlib.pyplot.specgram</td>
<td style="text-align:center">绘制光谱图</td>
</tr>
<tr>
<td style="text-align:center">matplotlib.pyplot.subplot</td>
<td style="text-align:center">绘制子图</td>
</tr>
</tbody>
</table>
<p>下面，我们就来一些常见类型的图像绘制及参数使用。</p>
<ul>
<li><p>折线图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt #载入 pyplot 绘图模块</span><br><span class="line">import numpy as np # 载入数值计算模块</span><br><span class="line"></span><br><span class="line"># 在 -2PI 和 2PI 之间等间距生成 1000 个值，也就是 x 坐标</span><br><span class="line">x = np.linspace(-2*np.pi, 2*np.pi, 1000)</span><br><span class="line"># 计算 y 坐标</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line"># 向方法中 `*args` 输入 x，y 坐标</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>柱形图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt #载入 pyplot 绘图模块</span><br><span class="line">import numpy as np # 载入数值计算模块</span><br><span class="line"></span><br><span class="line"># 在 -2PI 和 2PI 之间等间距生成 10 个值，也就是 X 坐标</span><br><span class="line">x = np.linspace(-2*np.pi, 2*np.pi, 10)</span><br><span class="line"># 计算 y 坐标</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line"># 向方法中 `*args` 输入 x，y 坐标</span><br><span class="line">plt.bar(x, abs(y))  # y 值取绝对值</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>散点图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt #载入 pyplot 绘图模块</span><br><span class="line">import numpy as np # 载入数值计算模块</span><br><span class="line"></span><br><span class="line"># x,y 的坐标均有 numpy 在 0 到 1 中随机生成 1000 个值</span><br><span class="line">x = np.random.normal(0,1,1000)</span><br><span class="line">y = np.random.normal(0,1,1000)</span><br><span class="line"></span><br><span class="line"># 向方法中 `*args` 输入 X，y 坐标</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>饼图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt #载入 pyplot 绘图模块</span><br><span class="line"></span><br><span class="line">Z = [1, 2, 3, 4, 5]</span><br><span class="line"># 绘图</span><br><span class="line">plt.pie(Z)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但是Matplotlib 默认的样式的确算不上美观。所以，我们需要设置绘图方法的参数，从而画出更漂亮和自己想要的图形。</p>
<h4 id="线型图进阶"><a href="#线型图进阶" class="headerlink" title="线型图进阶"></a>线型图进阶</h4><p>我们已经知道了，线型图通过 matplotlib.pyplot.plot(*args, **kwargs) 方法绘出。其中，args 代表数据输入，而 kwargs 的部分就是用于设置样式参数了。</p>
<ul>
<li>常用参数</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">alpha=</td>
<td style="text-align:center">设置线型的透明度，从 0.0 到 1.0</td>
</tr>
<tr>
<td style="text-align:center">color=</td>
<td style="text-align:center">设置线型的颜色</td>
</tr>
<tr>
<td style="text-align:center">fillstyle=</td>
<td style="text-align:center">设置线型的填充样式</td>
</tr>
<tr>
<td style="text-align:center">linestyle=</td>
<td style="text-align:center">设置线型的样式</td>
</tr>
<tr>
<td style="text-align:center">linewidth=</td>
<td style="text-align:center">设置线型的宽度</td>
</tr>
<tr>
<td style="text-align:center">marker=</td>
<td style="text-align:center">设置标记点的样式</td>
</tr>
</tbody>
</table>
<ul>
<li>颜色参数</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">color =参数值</th>
<th style="text-align:center">颜色</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">蓝色</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td style="text-align:center">绿色</td>
</tr>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">红色</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">白色</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">洋红色</td>
</tr>
<tr>
<td style="text-align:center">y</td>
<td style="text-align:center">黄色</td>
</tr>
<tr>
<td style="text-align:center">k</td>
<td style="text-align:center">黑色</td>
</tr>
</tbody>
</table>
<ul>
<li>颜色参数</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">linestyle =参数值</th>
<th style="text-align:center">线型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘-‘</td>
<td style="text-align:center">默认实线</td>
</tr>
<tr>
<td style="text-align:center">‘–’</td>
<td style="text-align:center">虚线</td>
</tr>
<tr>
<td style="text-align:center">‘-.’</td>
<td style="text-align:center">间断线</td>
</tr>
<tr>
<td style="text-align:center">‘:’</td>
<td style="text-align:center">点状线</td>
</tr>
</tbody>
</table>
<ul>
<li>样本点标记</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">marker =参数值</th>
<th style="text-align:center">样本点标记</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘.’</td>
<td style="text-align:center">实心点</td>
</tr>
<tr>
<td style="text-align:center">‘,’</td>
<td style="text-align:center">像素点</td>
</tr>
<tr>
<td style="text-align:center">‘o’</td>
<td style="text-align:center">空心点</td>
</tr>
<tr>
<td style="text-align:center">‘p’</td>
<td style="text-align:center">五角形</td>
</tr>
<tr>
<td style="text-align:center">‘x’</td>
<td style="text-align:center">x 形</td>
</tr>
<tr>
<td style="text-align:center">‘+’</td>
<td style="text-align:center">+ 形</td>
</tr>
</tbody>
</table>
<p>下面我们根据这些属性将我们的三角函数图像重新画一遍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*</span><br><span class="line"></span><br><span class="line">from matplotlib import pyplot as plt  # 载入 pyplot 绘图模块</span><br><span class="line">import numpy as np  # 载入数值计算模块</span><br><span class="line"></span><br><span class="line"># 在 -2PI 和 2PI 之间等间距生成 1000 个值，也就是 x 坐标</span><br><span class="line">x = np.linspace(-2 * np.pi, 2 * np.pi, 1000)</span><br><span class="line"># 计算 sin() 对应的纵坐标</span><br><span class="line">y1 = np.sin(x)</span><br><span class="line"># 计算 cos() 对应的纵坐标</span><br><span class="line">y2 = np.cos(x)</span><br><span class="line"></span><br><span class="line"># 向方法中 `*args` 输入 X，y 坐标</span><br><span class="line">plt.plot(x, y1, color=&apos;r&apos;, linestyle=&apos;--&apos;, linewidth=2, alpha=0.1)</span><br><span class="line">plt.plot(x, y2, color=&apos;b&apos;, linestyle=&apos;-&apos;, linewidth=2)</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2065390-a93c9becc6d20157.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线形图"></p>
<h4 id="散点图进阶"><a href="#散点图进阶" class="headerlink" title="散点图进阶"></a>散点图进阶</h4><p>除了线型图以外，散点图也是常用图形之一。例如，我们在使用机器学习算法聚类的时候，往往就会通过散点图将样本数据展示出来。Matplotlib 中，绘制散点图的方法我们已经知道了，那就是 matplotlib.pyplot.scatter()。接下来，我们就看一看它包含有哪些参数。<br>| 参数    | 含义|<br>| :————-: |:————-:|<br>| s=    | 散点大小|<br>| c=    | 散点颜色|<br>| marker=|     散点样式|<br>| cmap=    | 定义多类别散点的颜色|<br>| alpha=    | 点的透明度|<br>| edgecolors=    | 散点边缘颜色|<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*</span><br><span class="line"></span><br><span class="line">from matplotlib import pyplot as plt  # 载入 pyplot 绘图模块</span><br><span class="line">import numpy as np  # 载入数值计算模块</span><br><span class="line"></span><br><span class="line">x = np.random.rand(100) # 随机在 0 到 1 之间生成 100 个数值</span><br><span class="line">y = np.random.rand(100) # 随机在 0 到 1 之间生成 100 个数值</span><br><span class="line">colors = np.random.rand(100) # 随机在 0 到 1 之间生成 100 个数值</span><br><span class="line">size = np.random.normal(20, 30, 100) # 随机在 20 到 30 之间生成 100 个数值</span><br><span class="line"></span><br><span class="line"># 绘制散点图</span><br><span class="line">plt.scatter(x, y, s=size, c=colors)</span><br><span class="line">plt.show()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<h4 id="饼状图进阶"><a href="#饼状图进阶" class="headerlink" title="饼状图进阶"></a>饼状图进阶</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*</span><br><span class="line"></span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">label = &apos;Cat&apos;, &apos;Dog&apos;, &apos;Cattle&apos;, &apos;Sheep&apos;, &apos;Horse&apos; # 各类别标签</span><br><span class="line">color = &apos;r&apos;, &apos;g&apos;, &apos;r&apos;, &apos;g&apos;, &apos;y&apos; # 各类别颜色</span><br><span class="line">size = [1, 2, 3, 4, 5] # 各类别占比</span><br><span class="line">explode = (0, 0, 0, 0, 0.2) # 各类别的偏移半径</span><br><span class="line"># 绘制饼状图</span><br><span class="line">plt.pie(size, colors=color, explode=explode, labels=label, shadow=True, autopct=&apos;%1.1f%%&apos;)</span><br><span class="line"># 饼状图呈正圆</span><br><span class="line">plt.axis(&apos;equal&apos;)</span><br><span class="line"># 显示图</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h4 id="组合图"><a href="#组合图" class="headerlink" title="组合图"></a>组合图</h4><p>上面演示了三种常见图像的绘制。实际上，我们往往会遇到将几种类型的一样的图放在一张图内显示，也就是组合图的绘制。其实很简单，你只需要将需要或者的组合图样式放在一起就好了，比如柱形图和折线图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*</span><br><span class="line"></span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">x = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</span><br><span class="line">y_bar = [3, 4, 6, 8, 9, 10, 9, 11, 7, 8]</span><br><span class="line">y_line = [2, 3, 5, 7, 8, 9, 8, 10, 6, 7]</span><br><span class="line"></span><br><span class="line">plt.bar(x, y_bar)</span><br><span class="line">plt.plot(x, y_line, &apos;-o&apos;, color=&apos;y&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<h4 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h4><p>子图，就是将几张独立的图放在一张大图中呈现。在一些需要对比的情形下，子图非常有效。<br>Matplotlib 中，绘制子图的方法为matplotlib.pyplot.subplot()，我们通过该方法来控制各子图的显示顺序。其中规则为<code>subplot(行序号, 列序号, 图序号)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># 生成数据</span><br><span class="line">x = np.linspace(-2*np.pi, 2*np.pi) </span><br><span class="line"></span><br><span class="line">y1 = np.sin(x)</span><br><span class="line">y2 = np.cos(x)</span><br><span class="line"></span><br><span class="line"># 子图 1</span><br><span class="line">plt.subplot(2, 2, 1)</span><br><span class="line">plt.plot(x, y1, &apos;k&apos;)</span><br><span class="line"># 子图 2</span><br><span class="line">plt.subplot(2, 2, 2)</span><br><span class="line">plt.plot(x, y2, &apos;r&apos;)</span><br><span class="line"># 子图 3</span><br><span class="line">plt.subplot(2, 2, 3)</span><br><span class="line">plt.plot(x, y2, &apos;y&apos;)</span><br><span class="line"># 子图 4</span><br><span class="line">plt.subplot(2, 2, 4)</span><br><span class="line">plt.plot(x, y2, &apos;g&apos;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p><strong><em>更为高级的子图画法</em></strong><br>首先需要了解一下基础知识<br>画图需要生成一个figure(可理解为画布或进程)，此参数可无需设置,如未设置pyplot会自动帮你创建一个(figure 1)。接下来，要决定在figure中哪个位置画图，画多大的图。这就引入坐标点和大小的概念，整个figure按照X与Y轴横竖来平均切分，以0到1之间的数值来表示。 如：X轴上的0.1，代表了X轴总长自左向右的10%位置。<br>整个画图区域就是一个axes，通过Axes参数选项可以对画图区域的坐标点与大小进行设置，如未设置会自动帮接近覆盖整个figure的值。在一个figure中可添加多个Axes，就如一个画布中可以画一整副图，又或者可以画四宫图等等。axes参数设置如下：<br>axes([x,y,xs,ys])#其中x代表在X轴的<strong>位置</strong>，y代表在Y轴的<strong>位置</strong>，xs代表在X轴上<strong>向右延展</strong>的范围大小，yx代表在Y轴中<strong>向上延展</strong>的范围大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># 生成数据</span><br><span class="line">x = np.linspace(-2 * np.pi, 2 * np.pi)</span><br><span class="line"></span><br><span class="line">y1 = np.sin(x)</span><br><span class="line">y2 = np.cos(x)</span><br><span class="line"></span><br><span class="line"># 大图</span><br><span class="line">plt.axes([.1, .1, .8, .8])</span><br><span class="line">plt.plot(x, y1, &apos;k&apos;)</span><br><span class="line"># 小图</span><br><span class="line">plt.axes([.6, .6, .3, .3])</span><br><span class="line">plt.plot(x, y2, &apos;r&apos;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<h4 id="绘制图例"><a href="#绘制图例" class="headerlink" title="绘制图例"></a>绘制图例</h4><p>一般情况下，当绘制好图案后，还需要绘制图例。Matplotlib 中，图例可以通过 matplotlib.pyplot.legend() 方法绘制。我们又拿上面的正弦和余弦曲线举例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*</span><br><span class="line"></span><br><span class="line">from matplotlib import pyplot as plt  # 载入 pyplot 绘图模块</span><br><span class="line">import numpy as np  # 载入数值计算模块</span><br><span class="line"></span><br><span class="line"># 生成数据</span><br><span class="line">X = np.linspace(-2 * np.pi, 2 * np.pi, 1000)</span><br><span class="line">y1 = np.sin(X)</span><br><span class="line">y2 = np.cos(X)</span><br><span class="line"></span><br><span class="line"># 使用 label= 添加标签</span><br><span class="line">plt.plot(X, y1, color=&apos;r&apos;, linestyle=&apos;--&apos;, linewidth=2, label=&apos;sin 函数&apos;)</span><br><span class="line">plt.plot(X, y2, color=&apos;b&apos;, linestyle=&apos;-&apos;, linewidth=2, label=&apos;cos 函数&apos;)</span><br><span class="line"># 绘制图例</span><br><span class="line">plt.legend(loc=&apos;upper left&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们需要修改两个地方，也就是通过<code>label=</code>为每一条曲线添加标签。然后，增加一条<code>plt.legend(loc=&#39;upper left&#39;)</code>就可以了。其中，<code>loc=&#39;upper left&#39;</code>是指明图例的位置，例如这里是左上方。你还可以通过 down 和 right 组合实现位置的变换。</p>
<h4 id="图像标注"><a href="#图像标注" class="headerlink" title="图像标注"></a>图像标注</h4><p>当我们绘制一些较为复杂的图像时，阅读对象往往很难全面理解图像的含义。而此时，图像标注往往会起到画龙点睛的效果。图像标注，就是在画面上添加文字注释、指示箭头、图框等各类标注元素。</p>
<p>Matplotlib 中，文字标注的方法由 matplotlib.pyplot.text() 实现。最基本的样式为 matplotlib.pyplot.text(x, y, s)，其中 x, y 用于标注位置定位，s 代表标注的字符串。除此之外，你还可以通过 fontsize= , horizontalalignment= 等参数调整标注字体的大小，对齐样式等。<br>下面，我们举一个对柱形图进行文字标注的示例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*</span><br><span class="line">from matplotlib import pyplot as plt # 载入绘图模块</span><br><span class="line"></span><br><span class="line">x_bar = [10, 20, 30, 40, 50] #柱形图横坐标</span><br><span class="line">y_bar = [0.5, 0.6, 0.7, 0.4, 0.6] #柱形图纵坐标</span><br><span class="line">bars = plt.bar(x_bar, y_bar, color=&apos;blue&apos;,  width=2) # 绘制柱形图</span><br><span class="line">for i, rect in enumerate(bars):</span><br><span class="line">    x_text = rect.get_x() # 获取柱形图横坐标</span><br><span class="line">    y_text = rect.get_height() + 0.01 # 获取柱子的高度并增加 0.01</span><br><span class="line">    plt.text(x_text, y_text, &apos;%.1f&apos; % y_bar[i]) # 标注文字</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>除了文字标注之外，还可以通过 matplotlib.pyplot.annotate() 方法向图像中添加箭头等样式标注。接下来，我们向上面的例子中增添一行增加箭头标记的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 增加箭头标注</span><br><span class="line">   plt.annotate(&apos;Max&apos;, xy=(32, 0.6), xytext=(38, 0.6), arrowprops=dict(facecolor=&apos;black&apos;, width=1, headwidth=7))</span><br></pre></td></tr></table></figure></p>
<p>上面的示例中，xy=() 表示标注终点坐标，xytext=() 表示标注起点坐标。另外，arrowprops=() 用于设置箭头样式，facecolor= 设置颜色，width= 设置箭尾宽度，headwidth= 设置箭头宽度。在箭头绘制的过程中，还有一个 arrowstyle= 用于改变箭头的样式。另外，connectionstyle= 的参数可以用于更改箭头连接的样式。下图展示了常见的箭头连接样式。</p>
<h4 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h4><p><img src="http://upload-images.jianshu.io/upload_images/2065390-0b06438d7a23c191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">ax = plt.subplot(111)</span><br><span class="line">ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)</span><br><span class="line">ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)</span><br><span class="line">ax.xaxis.set_ticks_position(&apos;bottom&apos;)</span><br><span class="line">ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;, 0))</span><br><span class="line">ax.yaxis.set_ticks_position(&apos;left&apos;)</span><br><span class="line">ax.spines[&apos;left&apos;].set_position((&apos;data&apos;, 0))</span><br><span class="line">X = np.linspace(-np.pi, np.pi, 256, endpoint=True)</span><br><span class="line">C, S = np.cos(X), np.sin(X)</span><br><span class="line">plt.plot(X, C, color=&quot;blue&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label=&quot;Cos Function&quot;)</span><br><span class="line">plt.plot(X, S, color=&quot;red&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label=&quot;Sin Function&quot;)</span><br><span class="line">#设置x,y轴范围</span><br><span class="line">plt.xlim(X.min() * 1.1, X.max() * 1.1)</span><br><span class="line">plt.ylim(C.min() * 1.1, C.max() * 1.1)</span><br><span class="line">#设置x,y轴的坐标刻度</span><br><span class="line">plt.xticks([-np.pi, -np.pi / 2, 0, np.pi / 2, np.pi],</span><br><span class="line">           [r&apos;$-\pi$&apos;, r&apos;$-\pi/2$&apos;, r&apos;$0$&apos;, r&apos;$+\pi/2$&apos;, r&apos;$+\pi$&apos;])</span><br><span class="line">plt.yticks([-1, +1],</span><br><span class="line">           [r&apos;$-1$&apos;, r&apos;$+1$&apos;])</span><br><span class="line">t = 2 * np.pi / 3</span><br><span class="line">plt.plot([t, t], [0, np.cos(t)],</span><br><span class="line">         color=&apos;blue&apos;, linewidth=1.5, linestyle=&quot;--&quot;)</span><br><span class="line">plt.scatter([t, ], [np.cos(t), ], 50, color=&apos;blue&apos;)</span><br><span class="line">plt.annotate(r&apos;$\sin(\frac&#123;2\pi&#125;&#123;3&#125;)=\frac&#123;\sqrt&#123;3&#125;&#125;&#123;2&#125;$&apos;,</span><br><span class="line">             xy=(t, np.sin(t)), xycoords=&apos;data&apos;,</span><br><span class="line">             xytext=(+10, +30), textcoords=&apos;offset points&apos;, fontsize=16,</span><br><span class="line">             arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;))</span><br><span class="line">plt.plot([t, t], [0, np.sin(t)],</span><br><span class="line">         color=&apos;red&apos;, linewidth=1.5, linestyle=&quot;--&quot;)</span><br><span class="line">plt.scatter([t, ], [np.sin(t), ], 50, color=&apos;red&apos;)</span><br><span class="line">plt.annotate(r&apos;$\cos(\frac&#123;2\pi&#125;&#123;3&#125;)=-\frac&#123;1&#125;&#123;2&#125;$&apos;,</span><br><span class="line">             xy=(t, np.cos(t)), xycoords=&apos;data&apos;,</span><br><span class="line">             xytext=(-90, -50), textcoords=&apos;offset points&apos;, fontsize=16,</span><br><span class="line">             arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;))</span><br><span class="line"></span><br><span class="line">plt.legend(loc=&apos;upper left&apos;, frameon=False)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Matplotlib 是一个非常简单而又完善的开源绘图库。那么它到底有多简单呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="编程" scheme="https://zhangpu1211.github.io/categories/program/"/>
    
    
      <category term="python" scheme="https://zhangpu1211.github.io/tags/python/"/>
    
      <category term="matplotlib" scheme="https://zhangpu1211.github.io/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>phpstudy升级mysql5.7以及遇到的问题汇总</title>
    <link href="https://zhangpu1211.github.io/2017/09/05/phpstudy%E5%8D%87%E7%BA%A7mysql5-7%E4%BB%A5%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://zhangpu1211.github.io/2017/09/05/phpstudy升级mysql5-7以及遇到的问题汇总/</id>
    <published>2017-09-05T03:07:05.000Z</published>
    <updated>2017-09-05T03:08:06.730Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近学习java的时候建数据库，用到了create_time和update_time，我想设置成current_time，但是在mysql5,7之前貌似不支持这个操作，没办法那就升级一下吧！</p>
</blockquote>
<h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h4><p>首先当然是现在了，<a href="https://dev.mysql.com/downloads/file/?id=467269" target="_blank" rel="noopener">地址在这里</a>,你可能看到它会提示你登录，这么麻烦呢！肯定不适合我这个懒人了，往下看，果然有提示<strong><a href="https://dev.mysql.com/get/archives/mysql-5.7/mysql-5.7.17-winx64.zip" target="_blank" rel="noopener">No thanks, just start my download.</a></strong>，点击下载就行啦。</p>
<h4 id="升级mysql版本"><a href="#升级mysql版本" class="headerlink" title="升级mysql版本"></a>升级mysql版本</h4><ul>
<li>备份原来 phpStudy 中 MySQL 安装目录，这个备份因人而异，不过最关键的还是你的本地数据库了，最保险的做法就是导出sql文件，升级完成后在导入</li>
<li>解压下载的mysql文件，将内容复制到phpstudy中mysql目录下</li>
<li>复制一份 my-default.ini ，重命名为 my.ini</li>
<li><p>打开my.ini,增加如下内容，这里的路径为你原来phpstudy中mysql的路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">basedir=&quot;D:/phpStudy/MySQL/&quot;</span><br><span class="line">datadir=&quot;D:/phpStudy/MySQL/data/&quot;</span><br><span class="line">character-set-server=utf8</span><br><span class="line">port=3306</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加bin目录到系统环境变量path中</p>
</li>
<li>在mysql的bin目录下打开cmd，执行如下操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize</span><br><span class="line">mysqld -install</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>至此mysql升级结束，下面来填坑</p>
<h4 id="mysql安装后的问题"><a href="#mysql安装后的问题" class="headerlink" title="mysql安装后的问题"></a>mysql安装后的问题</h4><ul>
<li>打开后密码不正确<br>尝试修改 root 用户密码：<br>打开 my.ini，找到 [mysqld]，在下面添加：<code>skip-grant-tables</code>(此参数用于忘记mysql密码)<br>打开cmd，输入<code>mysql -u root -p</code>，会让你输入密码，直接回车即可。现在可以进入mysql了，那么我们可以修改默认密码。执行如下语句<code>update user set authentication_string=password(&quot;123456&quot;) where user=&quot;root&quot;;</code>5.7.11之前的版本用这个<code>update user set password=password(&quot;123456&quot;) where user=&quot;root&quot;;</code>密码修改完成。<strong>进入my.ini删除<code>skip-grant-tables</code></strong></li>
<li>但是在你用mysqlfront或者Navicat登录的时候会提示你密码已经过期<br>dmd进入mysql后，直接输入下面的命令(这个时候你输入刚才设置的密码)<br><code>SET PASSWORD = PASSWORD(&#39;123456&#39;);</code><br>然后你会发现navicat可以连接了</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近学习java的时候建数据库，用到了create_time和update_time，我想设置成current_time，但是在mysql5,7之前貌似不支持这个操作，没办法那就升级一下吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;下载
    
    </summary>
    
      <category term="工具" scheme="https://zhangpu1211.github.io/categories/tools/"/>
    
    
      <category term="mysql" scheme="https://zhangpu1211.github.io/tags/mysql/"/>
    
      <category term="phpstudy" scheme="https://zhangpu1211.github.io/tags/phpstudy/"/>
    
  </entry>
  
  <entry>
    <title>maven安装与aliyun仓库配置</title>
    <link href="https://zhangpu1211.github.io/2017/08/27/maven%E5%AE%89%E8%A3%85%E4%B8%8Ealiyun%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AE/"/>
    <id>https://zhangpu1211.github.io/2017/08/27/maven安装与aliyun仓库配置/</id>
    <published>2017-08-27T02:23:24.000Z</published>
    <updated>2017-08-27T02:30:34.486Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>MAVEN项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。</p>
</blockquote>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">下载地址</a>,选择对应操作系统版本，linux就是第一个啦，win就是第二个。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2065390-e9d2ce84ac64fde2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>linux解压命令<code>tar xzvf apache-maven-3.5.0-bin.tar.gz</code><br>window直接解压到你想要的目录即可</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>让我们看看官方文档怎么说<br>Alternatively use your preferred archive extraction tool.</p>
<ul>
<li>Add the bin directory of the created directory apache-maven-3.5.0 to the PATH environment variable</li>
<li>Confirm with mvn -v in a new shell. The result should look similar to</li>
</ul>
<p>简单来说就是讲路径添加到系统的环境变量中，然后用<code>mvn -v</code>来检测是否成功。在此我们默认各位的java环境已经配置成功！<br>windows:在path下添加<code>C:\Program Files\apache-maven-3.5.0\bin</code><br>linux下添加环境变量方法:<code>export PATH=/opt/apache-maven-3.5.0/bin:$PATH</code><br>可选配置：<br>MAVEN_OPTS环境变量：<br>该变量包含用于启动运行Maven的JVM的参数，可用于向Maven提供其他选项。可以使用值-Xms256m -Xmx512m定义JVM内存设置</p>
<h3 id="添加阿里云镜像和修改本地仓库位置"><a href="#添加阿里云镜像和修改本地仓库位置" class="headerlink" title="添加阿里云镜像和修改本地仓库位置"></a>添加阿里云镜像和修改本地仓库位置</h3><p>打开maven文件夹下conf/setting.xml，查找<strong><em>mirror</em></strong>和<strong><em>localRepository</em></strong>关键字,将以下代码复制到对应位置。最后复制一份setting.xml到你新修改的本地仓库<code>E:\repository</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirrors&gt;</span><br><span class="line">  	&lt;mirror&gt;</span><br><span class="line">        &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">        &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class="line">        &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line">    &lt;/mirror&gt; </span><br><span class="line">&lt;/mirrors&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;localRepository&gt;E:\repository&lt;/localRepository&gt;</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;MAVEN项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven
    
    </summary>
    
      <category term="编程" scheme="https://zhangpu1211.github.io/categories/program/"/>
    
    
      <category term="java" scheme="https://zhangpu1211.github.io/tags/java/"/>
    
      <category term="maven" scheme="https://zhangpu1211.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>vscode中使用git</title>
    <link href="https://zhangpu1211.github.io/2017/08/24/vscode%E4%B8%AD%E4%BD%BF%E7%94%A8git/"/>
    <id>https://zhangpu1211.github.io/2017/08/24/vscode中使用git/</id>
    <published>2017-08-24T10:36:12.000Z</published>
    <updated>2017-08-24T10:51:46.205Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>vscode简介</em></strong><br>VSCode是微软推出的一款轻量编辑器，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验。<br>布局：左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是<strong>资源管理器</strong>，<strong>搜索</strong>，<strong>GIT</strong>，<strong>调试</strong>，<strong>插件</strong>，右侧是打开文件的编辑区域，最多可同时打开三个编辑区域到侧边。在初次使用时如果本地没有安装git会提示先安装git，然后重启vscode。</p>
<p><strong><em>git下载地址</em></strong><br><strong><em><a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Downloading Git</a></em></strong><br><em>如果安装过程提示无法添加环境变量到path中，则需要将git安装目录下的cmd目录添加到系统的path变量下</em></p>
<p><strong><em>配置git</em></strong></p>
<ul>
<li><p>设置全局配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot; </span><br><span class="line">git config --global user.email &quot;your email&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入你的项目目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd d:/wamp/www/wap              //首先指定到你的项目目录下</span><br><span class="line">git init</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https://github.com/youtname/vscode.git   </span><br><span class="line">//用你仓库的url,vscode.git中vscode为仓库名称,使用时必须先创建</span><br><span class="line">git push -u origin master  //提交到你的仓库</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><em>正式使用</em></strong></p>
<ul>
<li><p>提交代码到git<br>回到vs code打开git工作区就会看到所有代码显示在这里<br><img src="http://upload-images.jianshu.io/upload_images/2065390-a262f07bfbd6248a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>点击+号，把所有文件提交到暂存区。<br>然后打开菜单选择–提交已暂存的<br><img src="http://upload-images.jianshu.io/upload_images/2065390-d29fcbab73a224b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>然后按提示随便在消息框里输入一个消息，再按ctrl+enter提交<br><img src="http://upload-images.jianshu.io/upload_images/2065390-2a14bac73c66427b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>然后把所有暂存的代码push云端，<br><img src="http://upload-images.jianshu.io/upload_images/2065390-3e8449a7a0936e07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>点击后，会弹出让你输入账号密码，把你托管平台的账号密码输入上去就行了<br>不出问题的话你整个项目就会提交到云端上了。<br>在vs中每次更新代码都会要输入账号密码，方便起见，可以配置一下让GIT记住密码账号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store   //在Git Bash输入这个命令就可以了</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步代码<br><strong>这里说下平时修改代码后提交到云端的使用，和本地代码和云端同步</strong><br>　　随便打开一个文件，添加一个注释<br><img src="http://upload-images.jianshu.io/upload_images/2065390-0c48e7a94592d088.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>可以看到git图标有一个提示，打开git工作区可以看到就是修改的这个文件<br><img src="http://upload-images.jianshu.io/upload_images/2065390-9f771ddc6682827b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>然后点击右侧的+号，把他暂存起来。<br>再在消息框里输入消息，按ctrl+enter提交暂存<br><img src="http://upload-images.jianshu.io/upload_images/2065390-1131357d55addbd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>再点击push提交，代码就提交到云端了。<br><img src="http://upload-images.jianshu.io/upload_images/2065390-d9d53c0c5a426050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>打开 码云就可以看到了。。<br><img src="http://upload-images.jianshu.io/upload_images/2065390-3834f1650889eccf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li>更新回本地<br>比如当你在家里修改了代码提交到云端后，回到公司只需要用vscode打开项目点击菜单中的pull就可以同步过来了。</li>
<li>克隆项目<br>打开Git Bash输入以下命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd d:/project   //指定存放的目录</span><br><span class="line">git clone https://github.com/youtname/your repository.git     //你的仓库地址</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;vscode简介&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;VSCode是微软推出的一款轻量编辑器，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验。&lt;br&gt;布局：左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是&lt;strong&gt;资
    
    </summary>
    
      <category term="工具" scheme="https://zhangpu1211.github.io/categories/tools/"/>
    
    
      <category term="vs" scheme="https://zhangpu1211.github.io/tags/vs/"/>
    
      <category term="git" scheme="https://zhangpu1211.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://zhangpu1211.github.io/2017/08/24/hello-world/"/>
    <id>https://zhangpu1211.github.io/2017/08/24/hello-world/</id>
    <published>2017-08-24T02:36:47.025Z</published>
    <updated>2017-08-24T02:36:47.025Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
