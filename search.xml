<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python解决八数码问题]]></title>
    <url>%2F2017%2F10%2F10%2Fpython%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[八数码问题也称为九宫问题。在3×3的棋盘，摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始状态转变成目标状态的移动棋子步数最少的移动步骤。 一开始也是两眼一抹黑，连八数码是什么都不知道，经过度娘得到如上结果。那该如何实现呢？如果移动数字的话，8个数字，每次移动有4种选择，那就是32个种移动方案。那移动空格就只有4种选择，一下子清楚了很多。至于存储方案当然是数组了，交换起来多方便，是吧？实现方式呢？最初实验要求使用回溯算法解决，什么，回溯？！那不是和深度优先一样吗？无脑走找结果？算了，先试试吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import numpy as np#返回两个数组对应位置相同值的个数def calc(state1): b = np.array([[1, 2, 3], [8, 0, 4], [7, 6, 5]]) postion = np.where(state1 == b) return len(state1[postion])#打印八数码def showInfo(a): for i in range(3): for j in range(3): print(a[i, j], end=&apos; &apos;) print(&quot;\n&quot;) print(&apos;-&gt;&apos;)directions = [&apos;up&apos;, &apos;down&apos;, &apos;left&apos;, &apos;right&apos;]def SubStates(state): subStates = [] row, col = np.where(state==0) for direction in directions: if &apos;left&apos; == direction and col &gt; 0: s = state.copy() s[row, col],s[row, col - 1] = s[row, col - 1],s[row, col] subStates.append(s) if &apos;up&apos; == direction and row &gt; 0: s = state.copy() s[row, col],s[row - 1, col] = s[row - 1, col],s[row, col] subStates.append(s) if &apos;down&apos; == direction and row &lt; 2: s = state.copy() s[row, col],s[row + 1, col] = s[row + 1, col],s[row, col] subStates.append(s) if &apos;right&apos; == direction and col &lt; 2: s = state.copy() s[row, col],s[row, col + 1] = s[row, col + 1],s[row, col] subStates.append(s) return subStatesdef DFS(first): stack = [] stack.append(first) count = -1 while stack: count += 1 node = stack.pop() showInfo(node) if calc(node) == 9: return True,count s = SubStates(node) #res = sorted(s, key=calc) for x in res: stack.append(x)#主函数def main(): start = np.array([[0, 1, 3], [8, 2, 4], [7, 6, 5]]) #start = np.array([[2, 8, 3], [1, 0, 4], [7, 6, 5]]) res,count = DFS(start) if res: print(&apos;经过%d次变换结束&apos; %count)if __name__ == &apos;__main__&apos;: main() 用迭代方式很容易的写出了深度优先算法，可是貌似跑不出结果。。。what a fuck，什么鬼？遂找了个只移动两次的，运行，还是不行。随机压栈太疯狂了，加点约束吧。每次找和最终结果最相似的出栈应该可以。（这里说一下为了防止无限次循环，用宽度优先搜素比较合适，只需把pop()改成pop(0),如果用到排序的话那就要按相似度由高到低排列了）嗯，加上这句res = sorted(s, key=calc),压栈前按相似度由低到高做一次排序。移动两次的果然跑出来了，可是移动多次的还是不行。得，再想办法吧。做一个界限函数，用八数码迭代出来的层数加上相似度来搜索。这个值在一定限度才入栈，否则舍弃。这里我将节点封装成一个类来实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import numpy as npclass eightPuzzle(object): directions = [&apos;up&apos;, &apos;down&apos;, &apos;left&apos;, &apos;right&apos;] max = 7 def __init__(self,arr,cost=0,parent=None): self.arr = arr self.cost = cost self.parent = parent def getCost(self): return self.cost # 返回两个数组对应位置相同值的个数 def calc(self,state): final = np.array([[1, 2, 3], [8, 0, 4], [7, 6, 5]]) postion = np.where(state.arr == final) return len(state.arr[postion]) # 打印八数码 def showInfo(self): for i in range(3): for j in range(3): print(self.arr[i, j], end=&apos; &apos;) print(&quot;\n&quot;) print(&apos;-&gt;&apos;) def calc2(self, state1, stop): for x in stop: postion = np.where(state1.arr == x.arr) if len(state1.arr[postion]) == 9: return True return False def SubStates(self): subStates = [] row, col = np.where(self.arr==0) for direction in self.directions: if &apos;left&apos; == direction and col &gt; 0: s = self.arr.copy() s[row, col],s[row, col - 1] = s[row, col - 1],s[row, col] new = eightPuzzle(s,self.cost+1,self) subStates.append(new) if &apos;up&apos; == direction and row &gt; 0: s = self.arr.copy() s[row, col],s[row - 1, col] = s[row - 1, col],s[row, col] new = eightPuzzle(s, self.cost + 1,self) subStates.append(new) if &apos;down&apos; == direction and row &lt; 2: s = self.arr.copy() s[row, col],s[row + 1, col] = s[row + 1, col],s[row, col] new = eightPuzzle(s, self.cost + 1,self) subStates.append(new) if &apos;right&apos; == direction and col &lt; 2: s = self.arr.copy() s[row, col],s[row, col + 1] = s[row, col + 1],s[row, col] new = eightPuzzle(s, self.cost + 1,self) subStates.append(new) return subStates def DFS(self): stack = [] stop = [] stack.append(self) count = -1 while True: if not stack: return False,count,node count += 1 #stack = sorted(stack, key=self.calc) node = stack.pop() stop.append(node) node.showInfo() if self.calc(node) == 9: return True,count,node s = node.SubStates() if s: res = sorted(s, key=self.calc) else: continue for x in res: if (x.cost + 9 - self.calc(x))&lt; eightPuzzle.max: if self.calc2(x,stop): continue stack.append(x)def showInfo(result): for node in result: for i in range(3): for j in range(3): print(node.arr[i, j], end=&apos; &apos;) print(&apos;\n&apos;) print(&apos;-&gt;&apos;)#主函数def main(): #start = np.array([[0, 1, 3], [8, 2, 4], [7, 6, 5]]) start = np.array([[2, 8, 3], [1, 0, 4], [7, 6, 5]]) p = eightPuzzle(start) res,count,node = p.DFS() result = [] if res: print(&apos;经过%d次变换结束&apos; %count) while node: result.append(node) node = node.parent result.reverse() showInfo(result) else: print(&apos;规定范围内未找到合适路径，可增大界值&apos;)if __name__ == &apos;__main__&apos;: main() 这次经过七次搜索得到了最终答案。这时候发现输出很有意思，会出现初始状态。因此在深度搜索的过程中加了一个stop表，用来存储已经出栈的元素，每次入栈的时候查看若已经存在则扔掉。此时运行6次出现答案。结束。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始Hadoop集群环境搭建]]></title>
    <url>%2F2017%2F09%2F10%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHadoop%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本篇文章将从头开始介绍Hadoop大数据平台的一系列搭建工作，主要是搭建的具体操作步骤，思想方面涉及甚少，可以自行补充 虚拟机下载安装我使用的是VMware station12，下载地址为链接：http://pan.baidu.com/s/1geX11pL 密码：uylp本软件为注册软件现提供一个注册码AV5R2-8LW53-484RP-H5YQZ-XU8RF，大家也可以自行百度。 centos下载因为工作中常用的为不带可视化界面的版本，现提供一个centos6.8_64下载，地址点我 centos安装打开安装好的VMware station，右键选择新建虚拟机，选择典型安装。选择稍后安装操作系统，点击下一步选择linux操作系统，版本为CentOS64位输入计算机名称以及你想要安装的位置指定磁盘容量，这里要说明的是你选择的20G并不会一下占用你20G的硬盘空间，而是跟随你虚拟机大小进行变化的点击完成即可此时你会发现在你VMwarestation左面有了安装的虚拟机，现在需要做两件事。 设定虚拟机镜像位置 更改电脑虚拟化设置。有的电脑并没有开启Intel虚拟化，因此不能安装64位虚拟机。检测的方法是点击开启此虚拟机，如果进入安装界面则证明你的虚拟化是打开的，否则会报错，这时你需要开机进入BIOS，Advanced-CPU Setup将Intel Virtualization Technology和VT-d打开设置完成后选择开启此虚拟机，进入系统安装界面。这里需要注意的就是skip测试你的安装媒体。剩下的都是可视化的安装，自己选择就可以。Linux环境配置 修改Linux的主机名进入vi /etc/sysconfig/network,修改内容 12NETWORKING=yesHOSTNAME=node-1 修改IP地址如果你此时执行ifconfig命令你会发现并没有常见的etho网卡，这时因为系统默认没有启动。需要将配置文件改成如下内容。首先进入配置文件vi /etc/sysconfig/network-scripts/ifcfg-eth0 123456DEVICE=eth0ONBOOT=yesBOOTPROTO=staticTYPE=EthernetIPADDR=192.168.213.100NETMASK=255.255.255.0 这里需要注意的是ip地址的设置，首先你需要查看你的网络连接方式，我采用默认的NAT模式，从下图可以看到子网地址为192.168.213.0，因此我设置的为192.168.213.100。另外如果你想让虚拟机联网需要设置gateway和dns。 配置好后用service network restart重启网络服务，用ifconfig可以查看是否配置成功。然后可以在Windows上ping该ip查看是否可以ping通。ping通后就可以使用putty或者SecureCRT连接虚拟机了。 配置主机名和IP地址的映射关系vi /etc/hosts打开hosts文件，新增一行192.168.213.100 node-1 关闭防火墙查看防火墙状态service iptables status关闭防火墙service iptables stop设置防火墙开机不启动chkconfig iptables off 最后reboot或者通过hostname node-1 以及exit,使我们配置的主机名生效 删除Mac地址与网卡映射文件我们想将这个虚拟机作为模板机，为了避免以后Mac地址冲突，因此要删除Mac地址与网卡映射文件，以后启动机器的时候会自动生成。rm -rf /etc/udev/rules.d/70-persistent-net.rules然后用halt关机创建克隆机做大数据肯定不可能只有一个虚拟机，我们现在用配置好的这台机器，克隆出几台虚拟机出来。 选择模板机，然后点击右键 –&gt; 选择Manage –&gt; clone -&gt;创建一个完整的克隆 –&gt;-&gt;配置机器的名字和存放位置 开启虚拟机之前一定要生成一个新的mac地址 开启虚拟机，修改其主机名和ip地址如果在执行service network restart命令时出现以下错误，则可能是没有删除模板机Mac地址与网卡映射文件，注意这个文件每次启动都会自动生成的。解决方法是rm -rf /etc/udev/rules.d/70-persistent-net.rules删除该文件然后重启都修改完成后可以用一台虚拟机依次ping其它虚拟机，可以ping通即可修改hosts文件在101机器上修改hosts文件，完成主机名和ip地址映射 ssh免密码登录 在第一台机器上生成一对钥匙，一个公钥，一个私钥ssh-keygen –t rsa执行上面的命令后，输入四个回车 将公钥拷贝到希望名登录的机器ssh-copy-id 192.168.213.102执行上面的命令第一次要输入第二台机器的密码 然后执行scp操作就不需要输入密码了scp /etc/hosts root@192.168.213.102:/etc，现在可以将修改好的hosts文件发送到其他具有公钥的机器。注意这种免密码登录是单向的，如果想相互免密码登录则需要在每一台机器上都生成一个公钥和一个私钥。Hadoop集群规划现在我们有四台机器，分别为node-1,node-2,node-3,node-4，我们要做成下图形式的架构。第一台作为主节点，其他三台作为从节点Java安装将安装包上传到虚拟机上 安装Java 创建文件夹mkdir /usr/java 解压tar -zxvf jdk.tar.gz -C /usr/java 添加环境变量进入文件vi /etc/profile，按G到文件末尾，按o插入一行，加入下面语句export JAVA_HOME=/usr/java/jdk1.8.0_111export PATH=$PATH:$JAVA_HOME/bin执行source /etc/profile重新加载环境变量 若需要传到其他虚拟机上则scp –r /usr/java/ node-2:/usrscp /etc/profile node-2:/etc Hadoop安装 解压Hadoopmkdir /bigdatatar -zxvf hadoop-2.6.5.tar.gz -C /bigdata/ 在Hadoop安装包目录下有几个比较重要的目录sbin : 启动或停止Hadoop相关服务的脚本bin ：对Hadoop相关服务（HDFS,YARN）进行操作的脚本etc : Hadoop的配置文件目录share ：Hadoop的依赖jar包和文档，文档可以被删掉lib ：Hadoop的本地库（对数据进行压缩解压缩功能的） 修改配置文件进入到Hadoop的etc目录下cd /bigdata/hadoop-2.6.5/etc/hadoop 修改第1个配置文vi hadoop-env.shexport JAVA_HOME=/usr/java/jdk1.8.0_111 修改第2个配置文件vi core-site.xml12345678910111213&lt;configuration&gt; &lt;!-- 配置hdfs的namenode（老大）的地址 --&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://node-1:9000&lt;/value&gt; &lt;/property&gt; &lt;!-- 配置Hadoop运行时产生数据的存储目录，不是临时的数据 --&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/bigdata/hadoop-2.6.5/tmp&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改第3个配置文件vi hdfs-site.xml1234567&lt;configuration&gt; &lt;!-- 指定HDFS存储数据的副本数据量 --&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;3&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改第4个配置文件mv mapred-site.xml.template mapred-site.xmlvi mapred-site.xml1234567&lt;configuration&gt; &lt;!-- 指定mapreduce编程模型运行在yarn上 --&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改第5个配置文件vi yarn-site.xml12345678910111213&lt;configuration&gt; &lt;!-- 指定yarn的老大（ResourceManager的地址） --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;node-1&lt;/value&gt; &lt;/property&gt; &lt;!-- mapreduce执行shuffle时获取数据的方式 --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 第6个配置文件slavesvi slaves原来的localhost要删掉123node-2node-3node-4 将配置好的Hadoop安装包拷贝到其他服务上123scp -r /bigdata node-2:/scp -r /bigdata node-3:/scp -r /bigdata node-4:/ 在第一台机器（NameNode所在的机器）上对hdfs进行初始化（格式化HDFS）cd /bigdata/hadoop-2.6.5/bin/./hdfs namenode -format 配置自己到自己的免密码登录，输入当前机器的密码ssh-copy-id node-1 在第一台机器（NameNode所在的机器）上对hdfs进行初始化（格式化HDFS）cd /bigdata/hadoop-2.6.5/bin/./hdfs namenode -format格式化成功的标志是出现以下提示配置自己到自己的免密码登录，输入当前机器的密码ssh-copy-id node-1 启动并测试Hadoop123cd /bigdata/hadoop-2.6.5/sbin/./start-dfs.sh./start-yarn.sh 可以使用jps检查进程是否存在 也可以访问网页测试访问hdfs的管理界面192.168.213.101:50070 访问yarn的管理界面192.168.213.101:8088 关闭hdfs/yarn服务12./stop-dfs.sh./stop-yarn.sh 上传文件到HDFS上上传文件/bigdata/hadoop-2.6.5/bin/hdfs dfs -put /root/install.log hdfs://node-1:9000/查看文件信息/bigdata/hadoop-2.6.5/bin/hdfs dfs -ls hdfs://node-1:9000/ HDFS动态扩容查看现在DataNode情况可以在Hadoop的bin目录下执行./hdfs dfsadmin -report，可以看到存活的DataNode。现在为3个。下面为扩容的具体步骤： 准备一台新的服务器（最好是跟原集群的机器相同配置） 为新的服务器准备系统环境（主机名、IP地址、防火墙、JDK环境、hosts文件） 将新的服务器连入原集群网络（测试是否可以ping通） 从原集群中拷贝一个hadoop的安装目录到新节点上，并且删除原datanode的工作目录（这里配置的为tmp目录） 修改/bigdata/hadoop-2.6.5/etc/hadoop/slaves 文件，加入新节点的主机名 在新节点上用命令：hadoop-daemon.sh start datanode 启动datanode，就会自动加入集群 重启start-dfs,start-yarnhadoop集群恢复终极解决方案 在每一台机器上用命令杀掉所有java进程： killall java 在每一台机器上删掉hadoop安装目录中的tmp文件夹 在node-1上格式化namenode： hadoop namenode -format 在node-1上执行脚本来启动整个集群： start-dfs.sh注意用这种方案会重新格式化hdsf，意味着原来上传的文件会全部丢失！！！补充：关闭HDFS集群的命令：在node-1上： stop-dfs.sh关闭YARN集群的命令：在node-1上： stop-yarn.sh]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>hdfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib 绘3D图]]></title>
    <url>%2F2017%2F09%2F05%2FMatplotlib-%E7%BB%983D%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Matplotlib 也可以绘制 3D 图像，与二维图像不同的是，绘制三维图像主要通过 mplot3d 模块实现。但是，使用 Matplotlib 绘制三维图像实际上是在二维画布上展示，所以一般绘制三维图像时，同样需要载入 pyplot 模块。mplot3d 模块下主要包含 4 个大类，分别是： mpl_toolkits.mplot3d.axes3d() mpl_toolkits.mplot3d.axis3d() mpl_toolkits.mplot3d.art3d() mpl_toolkits.mplot3d.proj3d() 其中，axes3d() 下面主要包含了各种实现绘图的类和方法。axis3d() 主要是包含了和坐标轴相关的类和方法。art3d() 包含了一些可将 2D 图像转换并用于 3D 绘制的类和方法。proj3d() 中包含一些零碎的类和方法，例如计算三维向量长度等。一般情况下，我们用到最多的就是 mpl_toolkits.mplot3d.axes3d() 中的mpl_toolkits.mplot3d.axes3d.Axes3D() 类，而 Axes3D() 下面又存在绘制不同类型 3D 图的方法。你可以通过下面的方式导入 Axes3D()。from mpl_toolkits.mplot3d.axes3d import Axes3D或from mpl_toolkits.mplot3d import Axes3D 三维散点图首先，我们导入 numpy 随机生成一组数据。123456import numpy as np# x, y, z 均为 0 到 1 之间的 100 个随机数x = np.random.normal(0, 1, 100)y = np.random.normal(0, 1, 100)z = np.random.normal(0, 1, 100) 接下来，开始绘图。第一步是载入 2D, 3D 绘图模块。12from mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as plt 第二步，使用 Axes3D() 创建 3D 图形对象。12fig = plt.figure()ax = Axes3D(fig) 最后，调用散点图绘制方法绘图并显示出来。12ax.scatter(x, y, z)plt.show() 三维线型图线形图和散点图相似，需要传入 x, y, z 三个坐标的数值。详细的代码如下。12345678910111213141516171819# 载入模块from mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as pltimport numpy as np# 生成数据x = np.linspace(-6 * np.pi, 6 * np.pi, 1000)y = np.sin(x)z = np.cos(x)# 创建 3D 图形对象fig = plt.figure()ax = Axes3D(fig)# 绘制线型图ax.plot(x, y, z)# 显示图plt.show() 三维柱状图绘制完线型图，我们继续尝试绘制三维柱状图，其实它的绘制步骤和上面同样非常相似。12345678910111213141516# 载入模块from mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as pltimport numpy as np# 创建 3D 图形对象fig = plt.figure()ax = Axes3D(fig)# 生成数据并绘图x = [0, 1, 2, 3, 4, 5, 6]for i in x: y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] z = abs(np.random.normal(1, 10, 10)) ax.bar(y, z, i, zdir=&apos;y&apos;, color=[&apos;r&apos;, &apos;g&apos;, &apos;b&apos;, &apos;y&apos;])plt.show() 三维图曲面图接下来需要绘制的三维曲面图要麻烦一些，我们需要对数据进行矩阵处理。其实和画二维等高线图很相似，只是多增加了一个维度。12345678910111213141516171819# 载入模块import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3D# 创建 3D 图形对象fig = plt.figure()ax = Axes3D(fig)# 生成数据X = np.arange(-2, 2, 0.1)Y = np.arange(-2, 2, 0.1)X, Y = np.meshgrid(X, Y)Z = np.sqrt(X ** 2 + Y ** 2)# 绘制曲面图，并使用 cmap 着色ax.plot_surface(X, Y, Z, cmap=plt.cm.winter)plt.show() cmap=plt.cm.winter 表示采用了 winter 配色方案，也就是下图的渐变色。 混合图绘制混合图就是将两种不同类型的图绘制在一张图里。绘制混合图一般有前提条件，那就是两种不同类型图的范围大致相同，否则将会出现严重的比例不协调，而使得混合图失去意义。1234567891011121314151617181920212223# -*- coding: utf-8 -*# 载入模块from mpl_toolkits.mplot3d import Axes3Dimport numpy as npimport matplotlib.pyplot as plt# 创建 3D 图形对象fig = plt.figure()ax = Axes3D(fig)# 生成数据并绘制图 1x1 = np.linspace(-3 * np.pi, 3 * np.pi, 500)y1 = np.sin(x1)ax.plot(x1, y1, zs=0, c=&apos;red&apos;)# 生成数据并绘制图 2x2 = np.random.normal(0, 1, 100)y2 = np.random.normal(0, 1, 100)z2 = np.random.normal(0, 1, 100)ax.scatter(x2, y2, z2)# 显示图plt.show() 子图绘制1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*# 载入模块from mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as pltimport numpy as np# 创建 1 张画布fig = plt.figure()#===============# 向画布添加子图 1 ax1 = fig.add_subplot(1, 2, 1, projection=&apos;3d&apos;)# 生成子图 1 数据x = np.linspace(-6 * np.pi, 6 * np.pi, 1000)y = np.sin(x)z = np.cos(x)# 绘制第 1 张图ax1.plot(x, y, z)#===============# 向画布添加子图 2ax2 = fig.add_subplot(1, 2, 2, projection=&apos;3d&apos;)# 生成子图 2 数据X = np.arange(-2, 2, 0.1)Y = np.arange(-2, 2, 0.1)X, Y = np.meshgrid(X, Y)Z = np.sqrt(X ** 2 + Y ** 2)# 绘制第 2 张图ax2.plot_surface(X, Y, Z, cmap=plt.cm.winter)# 显示图plt.show() 我们可以来看一下这些代码。由于两张子图是绘制在 1 张画布上面的，所以这里需要提前创建 1 张画布。然后通过.add_subplot()添加子图，子图序号和二维绘图相似，只是注意 3D 绘图时要添加projection=&#39;3d&#39;参数。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib 绘2D图]]></title>
    <url>%2F2017%2F09%2F05%2FMatplotlib-%E7%BB%982D%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Matplotlib 是一个非常简单而又完善的开源绘图库。那么它到底有多简单呢？ 基本知识首先官方文档奉上下面，我们通过 3 行代码绘制一张简单的折线图。123from matplotlib import pyplot as pltplt.plot([1,2,3,4,2,1,5,6,1])plt.show() plt.plot() 是 pyplot 模块下面的直线绘制（折线图）方法类。示例中包含了一个[1,2,3,4,2,1,5,6,1]列表，该列表的值默认为y值，而 x 值会从 0 到 n-1，这也就是为什么你会发现3反而对应的是4。 方法 含义 matplotlib.pyplot.angle_spectrum 绘制电子波谱图 matplotlib.pyplot.bar 绘制柱状图 matplotlib.pyplot.barh 绘制直方图 matplotlib.pyplot.broken_barh 绘制水平直方图 matplotlib.pyplot.contour 绘制等高线图 matplotlib.pyplot.errorbar 绘制误差线 matplotlib.pyplot.hexbin 绘制六边形图案 matplotlib.pyplot.hist 绘制柱形图 matplotlib.pyplot.hist2d 绘制水平柱状图 matplotlib.pyplot.imshow 以图像显示 matplotlib.pyplot.pie 绘制饼状图 matplotlib.pyplot.quiver 绘制量场图 matplotlib.pyplot.scatter 散点图 matplotlib.pyplot.specgram 绘制光谱图 matplotlib.pyplot.subplot 绘制子图 下面，我们就来一些常见类型的图像绘制及参数使用。 折线图 1234567891011from matplotlib import pyplot as plt #载入 pyplot 绘图模块import numpy as np # 载入数值计算模块# 在 -2PI 和 2PI 之间等间距生成 1000 个值，也就是 x 坐标x = np.linspace(-2*np.pi, 2*np.pi, 1000)# 计算 y 坐标y = np.sin(x)# 向方法中 `*args` 输入 x，y 坐标plt.plot(x, y)plt.show() 柱形图 1234567891011from matplotlib import pyplot as plt #载入 pyplot 绘图模块import numpy as np # 载入数值计算模块# 在 -2PI 和 2PI 之间等间距生成 10 个值，也就是 X 坐标x = np.linspace(-2*np.pi, 2*np.pi, 10)# 计算 y 坐标y = np.sin(x)# 向方法中 `*args` 输入 x，y 坐标plt.bar(x, abs(y)) # y 值取绝对值plt.show() 散点图 12345678910from matplotlib import pyplot as plt #载入 pyplot 绘图模块import numpy as np # 载入数值计算模块# x,y 的坐标均有 numpy 在 0 到 1 中随机生成 1000 个值x = np.random.normal(0,1,1000)y = np.random.normal(0,1,1000)# 向方法中 `*args` 输入 X，y 坐标plt.scatter(x, y)plt.show() 饼图 123456from matplotlib import pyplot as plt #载入 pyplot 绘图模块Z = [1, 2, 3, 4, 5]# 绘图plt.pie(Z)plt.show() 但是Matplotlib 默认的样式的确算不上美观。所以，我们需要设置绘图方法的参数，从而画出更漂亮和自己想要的图形。 线型图进阶我们已经知道了，线型图通过 matplotlib.pyplot.plot(args, *kwargs) 方法绘出。其中，args 代表数据输入，而 kwargs 的部分就是用于设置样式参数了。 常用参数 参数 含义 alpha= 设置线型的透明度，从 0.0 到 1.0 color= 设置线型的颜色 fillstyle= 设置线型的填充样式 linestyle= 设置线型的样式 linewidth= 设置线型的宽度 marker= 设置标记点的样式 颜色参数 color =参数值 颜色 b 蓝色 g 绿色 r 红色 w 白色 m 洋红色 y 黄色 k 黑色 颜色参数 linestyle =参数值 线型 ‘-‘ 默认实线 ‘–’ 虚线 ‘-.’ 间断线 ‘:’ 点状线 样本点标记 marker =参数值 样本点标记 ‘.’ 实心点 ‘,’ 像素点 ‘o’ 空心点 ‘p’ 五角形 ‘x’ x 形 ‘+’ + 形 下面我们根据这些属性将我们的三角函数图像重新画一遍123456789101112131415# -*- coding: utf-8 -*from matplotlib import pyplot as plt # 载入 pyplot 绘图模块import numpy as np # 载入数值计算模块# 在 -2PI 和 2PI 之间等间距生成 1000 个值，也就是 x 坐标x = np.linspace(-2 * np.pi, 2 * np.pi, 1000)# 计算 sin() 对应的纵坐标y1 = np.sin(x)# 计算 cos() 对应的纵坐标y2 = np.cos(x)# 向方法中 `*args` 输入 X，y 坐标plt.plot(x, y1, color=&apos;r&apos;, linestyle=&apos;--&apos;, linewidth=2, alpha=0.1)plt.plot(x, y2, color=&apos;b&apos;, linestyle=&apos;-&apos;, linewidth=2) 散点图进阶除了线型图以外，散点图也是常用图形之一。例如，我们在使用机器学习算法聚类的时候，往往就会通过散点图将样本数据展示出来。Matplotlib 中，绘制散点图的方法我们已经知道了，那就是 matplotlib.pyplot.scatter()。接下来，我们就看一看它包含有哪些参数。| 参数 | 含义|| :————-: |:————-:|| s= | 散点大小|| c= | 散点颜色|| marker=| 散点样式|| cmap= | 定义多类别散点的颜色|| alpha= | 点的透明度|| edgecolors= | 散点边缘颜色|1234567891011121314# -*- coding: utf-8 -*from matplotlib import pyplot as plt # 载入 pyplot 绘图模块import numpy as np # 载入数值计算模块x = np.random.rand(100) # 随机在 0 到 1 之间生成 100 个数值y = np.random.rand(100) # 随机在 0 到 1 之间生成 100 个数值colors = np.random.rand(100) # 随机在 0 到 1 之间生成 100 个数值size = np.random.normal(20, 30, 100) # 随机在 20 到 30 之间生成 100 个数值# 绘制散点图plt.scatter(x, y, s=size, c=colors)plt.show()plt.show() 饼状图进阶1234567891011121314# -*- coding: utf-8 -*import matplotlib.pyplot as pltlabel = &apos;Cat&apos;, &apos;Dog&apos;, &apos;Cattle&apos;, &apos;Sheep&apos;, &apos;Horse&apos; # 各类别标签color = &apos;r&apos;, &apos;g&apos;, &apos;r&apos;, &apos;g&apos;, &apos;y&apos; # 各类别颜色size = [1, 2, 3, 4, 5] # 各类别占比explode = (0, 0, 0, 0, 0.2) # 各类别的偏移半径# 绘制饼状图plt.pie(size, colors=color, explode=explode, labels=label, shadow=True, autopct=&apos;%1.1f%%&apos;)# 饼状图呈正圆plt.axis(&apos;equal&apos;)# 显示图plt.show() 组合图上面演示了三种常见图像的绘制。实际上，我们往往会遇到将几种类型的一样的图放在一张图内显示，也就是组合图的绘制。其实很简单，你只需要将需要或者的组合图样式放在一起就好了，比如柱形图和折线图。1234567891011# -*- coding: utf-8 -*import matplotlib.pyplot as pltx = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]y_bar = [3, 4, 6, 8, 9, 10, 9, 11, 7, 8]y_line = [2, 3, 5, 7, 8, 9, 8, 10, 6, 7]plt.bar(x, y_bar)plt.plot(x, y_line, &apos;-o&apos;, color=&apos;y&apos;)plt.show() 子图子图，就是将几张独立的图放在一张大图中呈现。在一些需要对比的情形下，子图非常有效。Matplotlib 中，绘制子图的方法为matplotlib.pyplot.subplot()，我们通过该方法来控制各子图的显示顺序。其中规则为subplot(行序号, 列序号, 图序号)1234567891011121314151617181920212223import numpy as npimport matplotlib.pyplot as plt# 生成数据x = np.linspace(-2*np.pi, 2*np.pi) y1 = np.sin(x)y2 = np.cos(x)# 子图 1plt.subplot(2, 2, 1)plt.plot(x, y1, &apos;k&apos;)# 子图 2plt.subplot(2, 2, 2)plt.plot(x, y2, &apos;r&apos;)# 子图 3plt.subplot(2, 2, 3)plt.plot(x, y2, &apos;y&apos;)# 子图 4plt.subplot(2, 2, 4)plt.plot(x, y2, &apos;g&apos;)plt.show() 更为高级的子图画法首先需要了解一下基础知识画图需要生成一个figure(可理解为画布或进程)，此参数可无需设置,如未设置pyplot会自动帮你创建一个(figure 1)。接下来，要决定在figure中哪个位置画图，画多大的图。这就引入坐标点和大小的概念，整个figure按照X与Y轴横竖来平均切分，以0到1之间的数值来表示。 如：X轴上的0.1，代表了X轴总长自左向右的10%位置。整个画图区域就是一个axes，通过Axes参数选项可以对画图区域的坐标点与大小进行设置，如未设置会自动帮接近覆盖整个figure的值。在一个figure中可添加多个Axes，就如一个画布中可以画一整副图，又或者可以画四宫图等等。axes参数设置如下：axes([x,y,xs,ys])#其中x代表在X轴的位置，y代表在Y轴的位置，xs代表在X轴上向右延展的范围大小，yx代表在Y轴中向上延展的范围大小。1234567891011121314151617import numpy as npimport matplotlib.pyplot as plt# 生成数据x = np.linspace(-2 * np.pi, 2 * np.pi)y1 = np.sin(x)y2 = np.cos(x)# 大图plt.axes([.1, .1, .8, .8])plt.plot(x, y1, &apos;k&apos;)# 小图plt.axes([.6, .6, .3, .3])plt.plot(x, y2, &apos;r&apos;)plt.show() 绘制图例一般情况下，当绘制好图案后，还需要绘制图例。Matplotlib 中，图例可以通过 matplotlib.pyplot.legend() 方法绘制。我们又拿上面的正弦和余弦曲线举例。12345678910111213141516# -*- coding: utf-8 -*from matplotlib import pyplot as plt # 载入 pyplot 绘图模块import numpy as np # 载入数值计算模块# 生成数据X = np.linspace(-2 * np.pi, 2 * np.pi, 1000)y1 = np.sin(X)y2 = np.cos(X)# 使用 label= 添加标签plt.plot(X, y1, color=&apos;r&apos;, linestyle=&apos;--&apos;, linewidth=2, label=&apos;sin 函数&apos;)plt.plot(X, y2, color=&apos;b&apos;, linestyle=&apos;-&apos;, linewidth=2, label=&apos;cos 函数&apos;)# 绘制图例plt.legend(loc=&apos;upper left&apos;)plt.show() 在这里，我们需要修改两个地方，也就是通过label=为每一条曲线添加标签。然后，增加一条plt.legend(loc=&#39;upper left&#39;)就可以了。其中，loc=&#39;upper left&#39;是指明图例的位置，例如这里是左上方。你还可以通过 down 和 right 组合实现位置的变换。 图像标注当我们绘制一些较为复杂的图像时，阅读对象往往很难全面理解图像的含义。而此时，图像标注往往会起到画龙点睛的效果。图像标注，就是在画面上添加文字注释、指示箭头、图框等各类标注元素。 Matplotlib 中，文字标注的方法由 matplotlib.pyplot.text() 实现。最基本的样式为 matplotlib.pyplot.text(x, y, s)，其中 x, y 用于标注位置定位，s 代表标注的字符串。除此之外，你还可以通过 fontsize= , horizontalalignment= 等参数调整标注字体的大小，对齐样式等。下面，我们举一个对柱形图进行文字标注的示例。123456789101112# -*- coding: utf-8 -*from matplotlib import pyplot as plt # 载入绘图模块x_bar = [10, 20, 30, 40, 50] #柱形图横坐标y_bar = [0.5, 0.6, 0.7, 0.4, 0.6] #柱形图纵坐标bars = plt.bar(x_bar, y_bar, color=&apos;blue&apos;, width=2) # 绘制柱形图for i, rect in enumerate(bars): x_text = rect.get_x() # 获取柱形图横坐标 y_text = rect.get_height() + 0.01 # 获取柱子的高度并增加 0.01 plt.text(x_text, y_text, &apos;%.1f&apos; % y_bar[i]) # 标注文字plt.show() 除了文字标注之外，还可以通过 matplotlib.pyplot.annotate() 方法向图像中添加箭头等样式标注。接下来，我们向上面的例子中增添一行增加箭头标记的代码。12# 增加箭头标注 plt.annotate(&apos;Max&apos;, xy=(32, 0.6), xytext=(38, 0.6), arrowprops=dict(facecolor=&apos;black&apos;, width=1, headwidth=7)) 上面的示例中，xy=() 表示标注终点坐标，xytext=() 表示标注起点坐标。另外，arrowprops=() 用于设置箭头样式，facecolor= 设置颜色，width= 设置箭尾宽度，headwidth= 设置箭头宽度。在箭头绘制的过程中，还有一个 arrowstyle= 用于改变箭头的样式。另外，connectionstyle= 的参数可以用于更改箭头连接的样式。下图展示了常见的箭头连接样式。 综合案例 123456789101112131415161718192021222324252627282930313233343536373839import numpy as npimport matplotlib.pyplot as pltax = plt.subplot(111)ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)ax.xaxis.set_ticks_position(&apos;bottom&apos;)ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;, 0))ax.yaxis.set_ticks_position(&apos;left&apos;)ax.spines[&apos;left&apos;].set_position((&apos;data&apos;, 0))X = np.linspace(-np.pi, np.pi, 256, endpoint=True)C, S = np.cos(X), np.sin(X)plt.plot(X, C, color=&quot;blue&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label=&quot;Cos Function&quot;)plt.plot(X, S, color=&quot;red&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label=&quot;Sin Function&quot;)#设置x,y轴范围plt.xlim(X.min() * 1.1, X.max() * 1.1)plt.ylim(C.min() * 1.1, C.max() * 1.1)#设置x,y轴的坐标刻度plt.xticks([-np.pi, -np.pi / 2, 0, np.pi / 2, np.pi], [r&apos;$-\pi$&apos;, r&apos;$-\pi/2$&apos;, r&apos;$0$&apos;, r&apos;$+\pi/2$&apos;, r&apos;$+\pi$&apos;])plt.yticks([-1, +1], [r&apos;$-1$&apos;, r&apos;$+1$&apos;])t = 2 * np.pi / 3plt.plot([t, t], [0, np.cos(t)], color=&apos;blue&apos;, linewidth=1.5, linestyle=&quot;--&quot;)plt.scatter([t, ], [np.cos(t), ], 50, color=&apos;blue&apos;)plt.annotate(r&apos;$\sin(\frac&#123;2\pi&#125;&#123;3&#125;)=\frac&#123;\sqrt&#123;3&#125;&#125;&#123;2&#125;$&apos;, xy=(t, np.sin(t)), xycoords=&apos;data&apos;, xytext=(+10, +30), textcoords=&apos;offset points&apos;, fontsize=16, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;))plt.plot([t, t], [0, np.sin(t)], color=&apos;red&apos;, linewidth=1.5, linestyle=&quot;--&quot;)plt.scatter([t, ], [np.sin(t), ], 50, color=&apos;red&apos;)plt.annotate(r&apos;$\cos(\frac&#123;2\pi&#125;&#123;3&#125;)=-\frac&#123;1&#125;&#123;2&#125;$&apos;, xy=(t, np.cos(t)), xycoords=&apos;data&apos;, xytext=(-90, -50), textcoords=&apos;offset points&apos;, fontsize=16, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;))plt.legend(loc=&apos;upper left&apos;, frameon=False)plt.show()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpstudy升级mysql5.7以及遇到的问题汇总]]></title>
    <url>%2F2017%2F09%2F05%2Fphpstudy%E5%8D%87%E7%BA%A7mysql5-7%E4%BB%A5%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[最近学习java的时候建数据库，用到了create_time和update_time，我想设置成current_time，但是在mysql5,7之前貌似不支持这个操作，没办法那就升级一下吧！ 下载地址首先当然是现在了，地址在这里,你可能看到它会提示你登录，这么麻烦呢！肯定不适合我这个懒人了，往下看，果然有提示No thanks, just start my download.，点击下载就行啦。 升级mysql版本 备份原来 phpStudy 中 MySQL 安装目录，这个备份因人而异，不过最关键的还是你的本地数据库了，最保险的做法就是导出sql文件，升级完成后在导入 解压下载的mysql文件，将内容复制到phpstudy中mysql目录下 复制一份 my-default.ini ，重命名为 my.ini 打开my.ini,增加如下内容，这里的路径为你原来phpstudy中mysql的路径 1234basedir=&quot;D:/phpStudy/MySQL/&quot;datadir=&quot;D:/phpStudy/MySQL/data/&quot;character-set-server=utf8port=3306 添加bin目录到系统环境变量path中 在mysql的bin目录下打开cmd，执行如下操作12mysqld --initializemysqld -install 至此mysql升级结束，下面来填坑 mysql安装后的问题 打开后密码不正确尝试修改 root 用户密码：打开 my.ini，找到 [mysqld]，在下面添加：skip-grant-tables(此参数用于忘记mysql密码)打开cmd，输入mysql -u root -p，会让你输入密码，直接回车即可。现在可以进入mysql了，那么我们可以修改默认密码。执行如下语句update user set authentication_string=password(&quot;123456&quot;) where user=&quot;root&quot;;5.7.11之前的版本用这个update user set password=password(&quot;123456&quot;) where user=&quot;root&quot;;密码修改完成。进入my.ini删除skip-grant-tables 但是在你用mysqlfront或者Navicat登录的时候会提示你密码已经过期dmd进入mysql后，直接输入下面的命令(这个时候你输入刚才设置的密码)SET PASSWORD = PASSWORD(&#39;123456&#39;);然后你会发现navicat可以连接了]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>phpstudy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven安装与aliyun仓库配置]]></title>
    <url>%2F2017%2F08%2F27%2Fmaven%E5%AE%89%E8%A3%85%E4%B8%8Ealiyun%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[MAVEN项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。 下载下载地址,选择对应操作系统版本，linux就是第一个啦，win就是第二个。 linux解压命令tar xzvf apache-maven-3.5.0-bin.tar.gzwindow直接解压到你想要的目录即可 安装让我们看看官方文档怎么说Alternatively use your preferred archive extraction tool. Add the bin directory of the created directory apache-maven-3.5.0 to the PATH environment variable Confirm with mvn -v in a new shell. The result should look similar to 简单来说就是讲路径添加到系统的环境变量中，然后用mvn -v来检测是否成功。在此我们默认各位的java环境已经配置成功！windows:在path下添加C:\Program Files\apache-maven-3.5.0\binlinux下添加环境变量方法:export PATH=/opt/apache-maven-3.5.0/bin:$PATH可选配置：MAVEN_OPTS环境变量：该变量包含用于启动运行Maven的JVM的参数，可用于向Maven提供其他选项。可以使用值-Xms256m -Xmx512m定义JVM内存设置 添加阿里云镜像和修改本地仓库位置打开maven文件夹下conf/setting.xml，查找mirror和localRepository关键字,将以下代码复制到对应位置。最后复制一份setting.xml到你新修改的本地仓库E:\repository12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;localRepository&gt;E:\repository&lt;/localRepository&gt;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode中使用git]]></title>
    <url>%2F2017%2F08%2F24%2Fvscode%E4%B8%AD%E4%BD%BF%E7%94%A8git%2F</url>
    <content type="text"><![CDATA[vscode简介VSCode是微软推出的一款轻量编辑器，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验。布局：左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是资源管理器，搜索，GIT，调试，插件，右侧是打开文件的编辑区域，最多可同时打开三个编辑区域到侧边。在初次使用时如果本地没有安装git会提示先安装git，然后重启vscode。 git下载地址Downloading Git如果安装过程提示无法添加环境变量到path中，则需要将git安装目录下的cmd目录添加到系统的path变量下 配置git 设置全局配置 12git config --global user.name &quot;your name&quot; git config --global user.email &quot;your email&quot; 进入你的项目目录 12345678cd d:/wamp/www/wap //首先指定到你的项目目录下git inittouch README.mdgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/youtname/vscode.git //用你仓库的url,vscode.git中vscode为仓库名称,使用时必须先创建git push -u origin master //提交到你的仓库 正式使用 提交代码到git回到vs code打开git工作区就会看到所有代码显示在这里点击+号，把所有文件提交到暂存区。然后打开菜单选择–提交已暂存的然后按提示随便在消息框里输入一个消息，再按ctrl+enter提交然后把所有暂存的代码push云端，点击后，会弹出让你输入账号密码，把你托管平台的账号密码输入上去就行了不出问题的话你整个项目就会提交到云端上了。在vs中每次更新代码都会要输入账号密码，方便起见，可以配置一下让GIT记住密码账号。 1git config --global credential.helper store //在Git Bash输入这个命令就可以了 同步代码这里说下平时修改代码后提交到云端的使用，和本地代码和云端同步 随便打开一个文件，添加一个注释可以看到git图标有一个提示，打开git工作区可以看到就是修改的这个文件然后点击右侧的+号，把他暂存起来。再在消息框里输入消息，按ctrl+enter提交暂存再点击push提交，代码就提交到云端了。打开 码云就可以看到了。。 更新回本地比如当你在家里修改了代码提交到云端后，回到公司只需要用vscode打开项目点击菜单中的pull就可以同步过来了。 克隆项目打开Git Bash输入以下命令12cd d:/project //指定存放的目录git clone https://github.com/youtname/your repository.git //你的仓库地址]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vs</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
